diff -urN linux-m68k/drivers/scsi/Kconfig linux-schmitz/drivers/scsi/Kconfig
--- linux-m68k/drivers/scsi/Kconfig	2006-11-19 21:35:33.000000000 +0100
+++ linux-schmitz/drivers/scsi/Kconfig	2006-11-19 21:37:26.000000000 +0100
@@ -1713,7 +1713,7 @@
 
 config ATARI_SCSI
 	tristate "Atari native SCSI support"
-	depends on ATARI && SCSI && BROKEN
+	depends on ATARI && SCSI
 	select SCSI_SPI_ATTRS
 	---help---
 	  If you have an Atari with built-in NCR5380 SCSI controller (TT,
diff -urN linux-m68k/drivers/scsi/atari_NCR5380.c linux-schmitz/drivers/scsi/atari_NCR5380.c
--- linux-m68k/drivers/scsi/atari_NCR5380.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/drivers/scsi/atari_NCR5380.c	2006-11-19 21:37:26.000000000 +0100
@@ -716,7 +716,7 @@
 	printk("NCR5380_print_status: no memory for print buffer\n");
 	return;
     }
-    len = NCR5380_proc_info(pr_bfr, &start, 0, PAGE_SIZE, HOSTNO, 0);
+    len = NCR5380_proc_info(instance, pr_bfr, &start, 0, PAGE_SIZE, 0);
     pr_bfr[len] = 0;
     printk("\n%s\n", pr_bfr);
     free_page((unsigned long) pr_bfr);
@@ -878,6 +878,46 @@
 }
 
 /* 
+ * our own old-style timeout update
+ */
+/*
+ * The strategy is to cause the timer code to call scsi_times_out()
+ * when the soonest timeout is pending.
+ * The arguments are used when we are queueing a new command, because
+ * we do not want to subtract the time used from this time, but when we
+ * set the timer, we want to take this value into account.
+ */
+
+int atari_scsi_update_timeout(Scsi_Cmnd * SCset, int timeout)
+{
+    int rtn;
+
+    /*
+     * We are using the new error handling code to actually register/deregister
+     * timers for timeout.
+     */
+
+    if (!timer_pending(&SCset->eh_timeout)) {
+	rtn = 0;
+    } else {
+	rtn = SCset->eh_timeout.expires - jiffies;
+    }
+
+    if (timeout == 0) {
+        del_timer(&SCset->eh_timeout);
+        SCset->eh_timeout.data = (unsigned long) NULL;
+        SCset->eh_timeout.expires = 0;
+    } else {
+        if (SCset->eh_timeout.data != (unsigned long) NULL) 
+            del_timer(&SCset->eh_timeout);
+        SCset->eh_timeout.data = (unsigned long) SCset;
+        SCset->eh_timeout.expires = jiffies + timeout;
+        add_timer(&SCset->eh_timeout);
+    }
+    return rtn;
+}
+
+/* 
  * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, 
  *	void (*done)(Scsi_Cmnd *)) 
  *
@@ -902,7 +942,7 @@
     Scsi_Cmnd *tmp;
     int oldto;
     unsigned long flags;
-    extern int update_timeout(Scsi_Cmnd * SCset, int timeout);
+    // extern int update_timeout(Scsi_Cmnd * SCset, int timeout);
 
 #if (NDEBUG & NDEBUG_NO_WRITE)
     switch (cmd->cmnd[0]) {
@@ -956,6 +996,7 @@
 
     cmd->result = 0;
 
+    // moved local_irq_save() from here
 
     /* 
      * Insert the cmd into the issue queue. Note that REQUEST SENSE 
@@ -964,7 +1005,6 @@
      * sense data is only guaranteed to be valid while the condition exists.
      */
 
-    local_irq_save(flags);
     /* ++guenther: now that the issue queue is being set up, we can lock ST-DMA.
      * Otherwise a running NCR5380_main may steal the lock.
      * Lock before actually inserting due to fairness reasons explained in
@@ -977,11 +1017,15 @@
      * because also a timer int can trigger an abort or reset, which would
      * alter queues and touch the lock.
      */
+#if 1
     if (!IS_A_TT()) {
-	oldto = update_timeout(cmd, 0);
+	oldto = atari_scsi_update_timeout(cmd, 0);
 	falcon_get_lock();
-	update_timeout(cmd, oldto);
+	atari_scsi_update_timeout(cmd, oldto);
     }
+#endif
+    // moved local_irq_save() here for now
+    local_irq_save(flags);
     if (!(hostdata->issue_queue) || (cmd->cmnd[0] == REQUEST_SENSE)) {
 	LIST(cmd, hostdata->issue_queue);
 	NEXT(cmd) = hostdata->issue_queue;
@@ -1435,7 +1479,7 @@
     local_irq_restore(flags);
 
     /* Wait for arbitration logic to complete */
-#if NCR_TIMEOUT
+#if defined(NCR_TIMEOUT)
     {
       unsigned long timeout = jiffies + 2*NCR_TIMEOUT;
 
diff -urN linux-m68k/drivers/scsi/atari_scsi.c linux-schmitz/drivers/scsi/atari_scsi.c
--- linux-m68k/drivers/scsi/atari_scsi.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/drivers/scsi/atari_scsi.c	2006-11-19 21:37:26.000000000 +0100
@@ -558,11 +558,11 @@
 
 	local_irq_save(flags);
 
-	while( !in_interrupt() && falcon_got_lock && stdma_others_waiting() )
+	while( !in_irq() && falcon_got_lock && stdma_others_waiting() )
 		sleep_on( &falcon_fairness_wait );
 
 	while (!falcon_got_lock) {
-		if (in_interrupt())
+		if (in_irq())
 			panic( "Falcon SCSI hasn't ST-DMA lock in interrupt" );
 		if (!falcon_trying_lock) {
 			falcon_trying_lock = 1;
@@ -764,7 +764,6 @@
 	return( 1 );
 }
 
-#ifdef MODULE
 int atari_scsi_release (struct Scsi_Host *sh)
 {
 	if (IS_A_TT())
@@ -773,7 +772,6 @@
 		atari_stram_free (atari_dma_buffer);
 	return 1;
 }
-#endif
 
 void __init atari_scsi_setup(char *str, int *ints)
 {
diff -urN linux-m68k/drivers/scsi/atari_scsi.h linux-schmitz/drivers/scsi/atari_scsi.h
--- linux-m68k/drivers/scsi/atari_scsi.h	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/drivers/scsi/atari_scsi.h	2006-11-19 21:37:26.000000000 +0100
@@ -21,11 +21,7 @@
 int atari_scsi_detect (struct scsi_host_template *);
 const char *atari_scsi_info (struct Scsi_Host *);
 int atari_scsi_reset (Scsi_Cmnd *, unsigned int);
-#ifdef MODULE
 int atari_scsi_release (struct Scsi_Host *);
-#else
-#define atari_scsi_release NULL
-#endif
 
 /* The values for CMD_PER_LUN and CAN_QUEUE are somehow arbitrary. Higher
  * values should work, too; try it! (but cmd_per_lun costs memory!) */
@@ -43,7 +39,9 @@
 
 #define ATARI_FALCON_CAN_QUEUE		8
 #define ATARI_FALCON_CMD_PER_LUN	1
-#define ATARI_FALCON_SG_TABLESIZE	SG_NONE
+/*  Set to 1 in order to shut up warning message in bio code
+ */
+#define ATARI_FALCON_SG_TABLESIZE	1	// SG_NONE
 
 #define	DEFAULT_USE_TAGGED_QUEUING	0
 
@@ -63,6 +61,32 @@
 #define	NCR5380_dma_xfer_len(i,cmd,phase) \
 	atari_dma_xfer_len(cmd->SCp.this_residual,cmd,((phase) & SR_IO) ? 0 : 1)
 
+/* former generic SCSI error handling stuff */
+
+#define SCSI_ABORT_SNOOZE 0
+#define SCSI_ABORT_SUCCESS 1
+#define SCSI_ABORT_PENDING 2
+#define SCSI_ABORT_BUSY 3
+#define SCSI_ABORT_NOT_RUNNING 4
+#define SCSI_ABORT_ERROR 5
+
+#define SCSI_RESET_SNOOZE 0
+#define SCSI_RESET_PUNT 1
+#define SCSI_RESET_SUCCESS 2
+#define SCSI_RESET_PENDING 3
+#define SCSI_RESET_WAKEUP 4
+#define SCSI_RESET_NOT_RUNNING 5
+#define SCSI_RESET_ERROR 6
+
+#define SCSI_RESET_SYNCHRONOUS		0x01
+#define SCSI_RESET_ASYNCHRONOUS		0x02
+#define SCSI_RESET_SUGGEST_BUS_RESET	0x04
+#define SCSI_RESET_SUGGEST_HOST_RESET	0x08
+
+#define SCSI_RESET_BUS_RESET 0x100
+#define SCSI_RESET_HOST_RESET 0x200
+#define SCSI_RESET_ACTION   0xff
+
 /* Debugging printk definitions:
  *
  *  ARB  -> arbitration
