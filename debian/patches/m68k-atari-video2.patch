diff -urNbBw -X diff-2.6.excl linux-2.6.18-debian-atari/drivers/video/atafb.c linux-2.6.18-m68k/drivers/video/atafb.c
--- linux-2.6.18-debian-atari/drivers/video/atafb.c	2006-12-20 14:25:38.000000000 +0100
+++ linux-2.6.18-m68k/drivers/video/atafb.c	2006-12-10 16:36:46.000000000 +0100
@@ -536,78 +536,34 @@
      *  If you change these, make sure to update DEFMODE_* as well!
      */
 
+    /*
+     *  ST/TT Video Modes
+     */
+
     {
-	/* 640x200, 15 kHz, 60 Hz (NTSC) */
-	"ntsc", 60, 640, 200, TAG_HIRES, 106, 86, 44, 16, 76, 2,
-	FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x400, 15 kHz, 60 Hz interlaced (NTSC) */
-	"ntsc-lace", 60, 640, 400, TAG_HIRES, 106, 86, 88, 33, 76, 4,
-	FB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x256, 15 kHz, 50 Hz (PAL) */
-	"pal", 50, 640, 256, TAG_HIRES, 106, 86, 40, 14, 76, 2,
-	FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x512, 15 kHz, 50 Hz interlaced (PAL) */
-	"pal-lace", 50, 640, 512, TAG_HIRES, 106, 86, 80, 29, 76, 4,
-	FB_SYNC_BROADCAST, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x480, 29 kHz, 57 Hz */
-	"multiscan", 57, 640, 480, TAG_SHRES, 96, 112, 29, 8, 72, 8,
+	/* 320x200, 15 kHz, 60 Hz (ST low) */
+	"st-low", 60, 320, 200, TAG_HIRES, 106, 86, 44, 16, 76, 2,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
-	/* 640x960, 29 kHz, 57 Hz interlaced */
-	"multiscan-lace", 57, 640, 960, TAG_SHRES, 96, 112, 58, 16, 72, 16,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x200, 15 kHz, 72 Hz */
-	"euro36", 72, 640, 200, TAG_HIRES, 92, 124, 6, 6, 52, 5,
+	/* 640x200, 15 kHz, 60 Hz (ST medium) */
+	"st-mid", 60, 640, 200, TAG_HIRES, 106, 86, 88, 33, 76, 4,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
-	/* 640x400, 15 kHz, 72 Hz interlaced */
-	"euro36-lace", 72, 640, 400, TAG_HIRES, 92, 124, 12, 12, 52, 10,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x400, 29 kHz, 68 Hz */
-	"euro72", 68, 640, 400, TAG_SHRES, 164, 92, 9, 9, 80, 8,
+	/* 640x400, 15 kHz, 60 Hz (ST high) */
+	"st-high", 60, 640, 400, TAG_HIRES, 106, 86, 40, 14, 76, 2,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
-	/* 640x800, 29 kHz, 68 Hz interlaced */
-	"euro72-lace", 68, 640, 800, TAG_SHRES, 164, 92, 18, 18, 80, 16,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 800x300, 23 kHz, 70 Hz */
-	"super72", 70, 800, 300, TAG_SHRES, 212, 140, 10, 11, 80, 7,
+	/* 320x480, 15 kHz, 60 Hz (TT low) */
+	"tt-low", 60, 320, 480, TAG_HIRES, 106, 86, 80, 29, 76, 4,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
-	/* 800x600, 23 kHz, 70 Hz interlaced */
-	"super72-lace", 70, 800, 600, TAG_SHRES, 212, 140, 20, 22, 80, 14,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x200, 27 kHz, 57 Hz doublescan */
-	"dblntsc", 57, 640, 200, TAG_SHRES, 196, 124, 18, 17, 80, 4,
-	0, FB_VMODE_DOUBLE | FB_VMODE_YWRAP
-    }, {
-	/* 640x400, 27 kHz, 57 Hz */
-	"dblntsc-ff", 57, 640, 400, TAG_SHRES, 196, 124, 36, 35, 80, 7,
+	/* 640x480, 29 kHz, 57 Hz (TT medium) */
+	"tt-mid", 60, 640, 480, TAG_SHRES, 96, 112, 29, 8, 72, 8,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     }, {
-	/* 640x800, 27 kHz, 57 Hz interlaced */
-	"dblntsc-lace", 57, 640, 800, TAG_SHRES, 196, 124, 72, 70, 80, 14,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x256, 27 kHz, 47 Hz doublescan */
-	"dblpal", 47, 640, 256, TAG_SHRES, 196, 124, 14, 13, 80, 4,
-	0, FB_VMODE_DOUBLE | FB_VMODE_YWRAP
-    }, {
-	/* 640x512, 27 kHz, 47 Hz */
-	"dblpal-ff", 47, 640, 512, TAG_SHRES, 196, 124, 28, 27, 80, 7,
+	/* 1280x960, 29 kHz, 60 Hz (TT high) */
+	"tt-high", 57, 640, 960, TAG_SHRES, 96, 112, 58, 16, 72, 16,
 	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
-    }, {
-	/* 640x1024, 27 kHz, 47 Hz interlaced */
-	"dblpal-lace", 47, 640, 1024, TAG_SHRES, 196, 124, 56, 54, 80, 14,
-	0, FB_VMODE_INTERLACED | FB_VMODE_YWRAP
     },
 
     /*
@@ -624,6 +580,16 @@
 	FB_SYNC_VERT_HIGH_ACT | FB_SYNC_COMP_HIGH_ACT, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
     },
 
+    /*
+     *  Falcon HiRes Video Modes
+     */
+
+    {
+	/* 896x608, 31 kHz, 60 Hz (Falcon High) */
+	"falh", 60, 896, 608, TAG_SHRES, 64, 96, 30, 9, 112, 2,
+	0, FB_VMODE_NONINTERLACED | FB_VMODE_YWRAP
+    }, 
+
 };
 
 #define NUM_TOTAL_MODES  ARRAY_SIZE(atafb_modedb)
@@ -632,10 +598,10 @@
 
  /* default modes */
 
-#define DEFMODE_TT	    2	/* "pal" for PAL OCS/ECS */
-#define DEFMODE_F30	    0	/* "ntsc" for NTSC OCS/ECS */
-#define DEFMODE_STE   	    3	/* "pal-lace" for flicker fixed PAL (A3000) */
-#define DEFMODE_EXT  	    1	/* "ntsc-lace" for flicker fixed NTSC (A3000) */
+#define DEFMODE_TT	    5	/* "tt-high" for TT */
+#define DEFMODE_F30	    7	/* "vga70" for Falcon */
+#define DEFMODE_STE   	    2	/* "st-high" for ST/E */
+#define DEFMODE_EXT  	    1	/* "vga" for external */
 
 
 static int
@@ -2781,6 +2747,10 @@
 	return 0;
 }
 
+/*
+ * generic drawing routines; imageblit needs updating for image depth > 1
+ */
+
 #if BITS_PER_LONG == 32
 #define BYTES_PER_LONG	4
 #define SHIFT_PER_LONG	5
@@ -2791,596 +2761,6 @@
 #define Please update me
 #endif
 
-
-    /*
-     *  Compose two values, using a bitmask as decision value
-     *  This is equivalent to (a & mask) | (b & ~mask)
-     */
-
-static inline unsigned long comp(unsigned long a, unsigned long b,
-				 unsigned long mask)
-{
-	return ((a ^ b) & mask) ^ b;
-}
-
-
-static inline unsigned long xor(unsigned long a, unsigned long b,
-				unsigned long mask)
-{
-	return (a & mask) ^ b;
-}
-
-
-    /*
-     *  Unaligned forward bit copy using 32-bit or 64-bit memory accesses
-     */
-
-static void bitcpy(unsigned long *dst, int dst_idx, const unsigned long *src,
-		   int src_idx, u32 n)
-{
-	unsigned long first, last;
-	int shift = dst_idx-src_idx, left, right;
-	unsigned long d0, d1;
-	int m;
-
-	if (!n)
-		return;
-
-	shift = dst_idx-src_idx;
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));
-
-	if (!shift) {
-		// Same alignment for source and dest
-
-		if (dst_idx+n <= BITS_PER_LONG) {
-			// Single word
-			if (last)
-				first &= last;
-			*dst = comp(*src, *dst, first);
-		} else {
-			// Multiple destination words
-			// Leading bits
-			if (first) {
-				*dst = comp(*src, *dst, first);
-				dst++;
-				src++;
-				n -= BITS_PER_LONG-dst_idx;
-			}
-
-			// Main chunk
-			n /= BITS_PER_LONG;
-			while (n >= 8) {
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				*dst++ = *src++;
-				n -= 8;
-			}
-			while (n--)
-				*dst++ = *src++;
-
-			// Trailing bits
-			if (last)
-				*dst = comp(*src, *dst, last);
-		}
-	} else {
-		// Different alignment for source and dest
-
-		right = shift & (BITS_PER_LONG-1);
-		left = -shift & (BITS_PER_LONG-1);
-
-		if (dst_idx+n <= BITS_PER_LONG) {
-			// Single destination word
-			if (last)
-				first &= last;
-			if (shift > 0) {
-				// Single source word
-				*dst = comp(*src >> right, *dst, first);
-			} else if (src_idx+n <= BITS_PER_LONG) {
-				// Single source word
-				*dst = comp(*src << left, *dst, first);
-			} else {
-				// 2 source words
-				d0 = *src++;
-				d1 = *src;
-				*dst = comp(d0 << left | d1 >> right, *dst,
-					    first);
-			}
-		} else {
-			// Multiple destination words
-			d0 = *src++;
-			// Leading bits
-			if (shift > 0) {
-				// Single source word
-				*dst = comp(d0 >> right, *dst, first);
-				dst++;
-				n -= BITS_PER_LONG-dst_idx;
-			} else {
-				// 2 source words
-				d1 = *src++;
-				*dst = comp(d0 << left | d1 >> right, *dst,
-					    first);
-				d0 = d1;
-				dst++;
-				n -= BITS_PER_LONG-dst_idx;
-			}
-
-			// Main chunk
-			m = n % BITS_PER_LONG;
-			n /= BITS_PER_LONG;
-			while (n >= 4) {
-				d1 = *src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = *src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = *src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = *src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				n -= 4;
-			}
-			while (n--) {
-				d1 = *src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-			}
-
-			// Trailing bits
-			if (last) {
-				if (m <= right) {
-					// Single source word
-					*dst = comp(d0 << left, *dst, last);
-				} else {
-					// 2 source words
-					d1 = *src;
-					*dst = comp(d0 << left | d1 >> right,
-						    *dst, last);
-				}
-			}
-		}
-	}
-}
-
-
-    /*
-     *  Unaligned reverse bit copy using 32-bit or 64-bit memory accesses
-     */
-
-static void bitcpy_rev(unsigned long *dst, int dst_idx,
-		       const unsigned long *src, int src_idx, u32 n)
-{
-	unsigned long first, last;
-	int shift = dst_idx-src_idx, left, right;
-	unsigned long d0, d1;
-	int m;
-
-	if (!n)
-		return;
-
-	dst += (n-1)/BITS_PER_LONG;
-	src += (n-1)/BITS_PER_LONG;
-	if ((n-1) % BITS_PER_LONG) {
-		dst_idx += (n-1) % BITS_PER_LONG;
-		dst += dst_idx >> SHIFT_PER_LONG;
-		dst_idx &= BITS_PER_LONG-1;
-		src_idx += (n-1) % BITS_PER_LONG;
-		src += src_idx >> SHIFT_PER_LONG;
-		src_idx &= BITS_PER_LONG-1;
-	}
-
-	shift = dst_idx-src_idx;
-	first = ~0UL << (BITS_PER_LONG-1-dst_idx);
-	last = ~(~0UL << (BITS_PER_LONG-1-((dst_idx-n) % BITS_PER_LONG)));
-
-	if (!shift) {
-		// Same alignment for source and dest
-
-		if ((unsigned long)dst_idx+1 >= n) {
-			// Single word
-			if (last)
-				first &= last;
-			*dst = comp(*src, *dst, first);
-		} else {
-			// Multiple destination words
-			// Leading bits
-			if (first) {
-				*dst = comp(*src, *dst, first);
-				dst--;
-				src--;
-				n -= dst_idx+1;
-			}
-
-			// Main chunk
-			n /= BITS_PER_LONG;
-			while (n >= 8) {
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				*dst-- = *src--;
-				n -= 8;
-			}
-			while (n--)
-				*dst-- = *src--;
-
-			// Trailing bits
-			if (last)
-				*dst = comp(*src, *dst, last);
-		}
-	} else {
-		// Different alignment for source and dest
-
-		right = shift & (BITS_PER_LONG-1);
-		left = -shift & (BITS_PER_LONG-1);
-
-		if ((unsigned long)dst_idx+1 >= n) {
-			// Single destination word
-			if (last)
-				first &= last;
-			if (shift < 0) {
-				// Single source word
-				*dst = comp(*src << left, *dst, first);
-			} else if (1+(unsigned long)src_idx >= n) {
-				// Single source word
-				*dst = comp(*src >> right, *dst, first);
-			} else {
-				// 2 source words
-				d0 = *src--;
-				d1 = *src;
-				*dst = comp(d0 >> right | d1 << left, *dst,
-					    first);
-			}
-		} else {
-			// Multiple destination words
-			d0 = *src--;
-			// Leading bits
-			if (shift < 0) {
-				// Single source word
-				*dst = comp(d0 << left, *dst, first);
-				dst--;
-				n -= dst_idx+1;
-			} else {
-				// 2 source words
-				d1 = *src--;
-				*dst = comp(d0 >> right | d1 << left, *dst,
-					    first);
-				d0 = d1;
-				dst--;
-				n -= dst_idx+1;
-			}
-
-			// Main chunk
-			m = n % BITS_PER_LONG;
-			n /= BITS_PER_LONG;
-			while (n >= 4) {
-				d1 = *src--;
-				*dst-- = d0 >> right | d1 << left;
-				d0 = d1;
-				d1 = *src--;
-				*dst-- = d0 >> right | d1 << left;
-				d0 = d1;
-				d1 = *src--;
-				*dst-- = d0 >> right | d1 << left;
-				d0 = d1;
-				d1 = *src--;
-				*dst-- = d0 >> right | d1 << left;
-				d0 = d1;
-				n -= 4;
-			}
-			while (n--) {
-				d1 = *src--;
-				*dst-- = d0 >> right | d1 << left;
-				d0 = d1;
-			}
-
-			// Trailing bits
-			if (last) {
-				if (m <= left) {
-					// Single source word
-					*dst = comp(d0 >> right, *dst, last);
-				} else {
-					// 2 source words
-					d1 = *src;
-					*dst = comp(d0 >> right | d1 << left,
-						    *dst, last);
-				}
-			}
-		}
-	}
-}
-
-
-    /*
-     *  Unaligned forward inverting bit copy using 32-bit or 64-bit memory
-     *  accesses
-     */
-
-static void bitcpy_not(unsigned long *dst, int dst_idx,
-		       const unsigned long *src, int src_idx, u32 n)
-{
-	unsigned long first, last;
-	int shift = dst_idx-src_idx, left, right;
-	unsigned long d0, d1;
-	int m;
-
-	if (!n)
-		return;
-
-	shift = dst_idx-src_idx;
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));
-
-	if (!shift) {
-		// Same alignment for source and dest
-
-		if (dst_idx+n <= BITS_PER_LONG) {
-			// Single word
-			if (last)
-				first &= last;
-			*dst = comp(~*src, *dst, first);
-		} else {
-			// Multiple destination words
-			// Leading bits
-			if (first) {
-				*dst = comp(~*src, *dst, first);
-				dst++;
-				src++;
-				n -= BITS_PER_LONG-dst_idx;
-			}
-
-			// Main chunk
-			n /= BITS_PER_LONG;
-			while (n >= 8) {
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				*dst++ = ~*src++;
-				n -= 8;
-			}
-			while (n--)
-				*dst++ = ~*src++;
-
-			// Trailing bits
-			if (last)
-				*dst = comp(~*src, *dst, last);
-		}
-	} else {
-		// Different alignment for source and dest
-
-		right = shift & (BITS_PER_LONG-1);
-		left = -shift & (BITS_PER_LONG-1);
-
-		if (dst_idx+n <= BITS_PER_LONG) {
-			// Single destination word
-			if (last)
-				first &= last;
-			if (shift > 0) {
-				// Single source word
-				*dst = comp(~*src >> right, *dst, first);
-			} else if (src_idx+n <= BITS_PER_LONG) {
-				// Single source word
-				*dst = comp(~*src << left, *dst, first);
-			} else {
-				// 2 source words
-				d0 = ~*src++;
-				d1 = ~*src;
-				*dst = comp(d0 << left | d1 >> right, *dst,
-					    first);
-			}
-		} else {
-			// Multiple destination words
-			d0 = ~*src++;
-			// Leading bits
-			if (shift > 0) {
-				// Single source word
-				*dst = comp(d0 >> right, *dst, first);
-				dst++;
-				n -= BITS_PER_LONG-dst_idx;
-			} else {
-				// 2 source words
-				d1 = ~*src++;
-				*dst = comp(d0 << left | d1 >> right, *dst,
-					    first);
-				d0 = d1;
-				dst++;
-				n -= BITS_PER_LONG-dst_idx;
-			}
-
-			// Main chunk
-			m = n % BITS_PER_LONG;
-			n /= BITS_PER_LONG;
-			while (n >= 4) {
-				d1 = ~*src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = ~*src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = ~*src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				d1 = ~*src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-				n -= 4;
-			}
-			while (n--) {
-				d1 = ~*src++;
-				*dst++ = d0 << left | d1 >> right;
-				d0 = d1;
-			}
-
-			// Trailing bits
-			if (last) {
-				if (m <= right) {
-					// Single source word
-					*dst = comp(d0 << left, *dst, last);
-				} else {
-					// 2 source words
-					d1 = ~*src;
-					*dst = comp(d0 << left | d1 >> right,
-						    *dst, last);
-				}
-			}
-		}
-	}
-}
-
-
-    /*
-     *  Unaligned 32-bit pattern fill using 32/64-bit memory accesses
-     */
-
-static void bitfill32(unsigned long *dst, int dst_idx, u32 pat, u32 n)
-{
-	unsigned long val = pat;
-	unsigned long first, last;
-
-	if (!n)
-		return;
-
-#if BITS_PER_LONG == 64
-	val |= val << 32;
-#endif
-
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));
-
-	if (dst_idx+n <= BITS_PER_LONG) {
-		// Single word
-		if (last)
-			first &= last;
-		*dst = comp(val, *dst, first);
-	} else {
-		// Multiple destination words
-		// Leading bits
-		if (first) {
-			*dst = comp(val, *dst, first);
-			dst++;
-			n -= BITS_PER_LONG-dst_idx;
-		}
-
-		// Main chunk
-		n /= BITS_PER_LONG;
-		while (n >= 8) {
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			*dst++ = val;
-			n -= 8;
-		}
-		while (n--)
-			*dst++ = val;
-
-		// Trailing bits
-		if (last)
-			*dst = comp(val, *dst, last);
-	}
-}
-
-
-    /*
-     *  Unaligned 32-bit pattern xor using 32/64-bit memory accesses
-     */
-
-static void bitxor32(unsigned long *dst, int dst_idx, u32 pat, u32 n)
-{
-	unsigned long val = pat;
-	unsigned long first, last;
-
-	if (!n)
-		return;
-
-#if BITS_PER_LONG == 64
-	val |= val << 32;
-#endif
-
-	first = ~0UL >> dst_idx;
-	last = ~(~0UL >> ((dst_idx+n) % BITS_PER_LONG));
-
-	if (dst_idx+n <= BITS_PER_LONG) {
-		// Single word
-		if (last)
-			first &= last;
-		*dst = xor(val, *dst, first);
-	} else {
-		// Multiple destination words
-		// Leading bits
-		if (first) {
-			*dst = xor(val, *dst, first);
-			dst++;
-			n -= BITS_PER_LONG-dst_idx;
-		}
-
-		// Main chunk
-		n /= BITS_PER_LONG;
-		while (n >= 4) {
-			*dst++ ^= val;
-			*dst++ ^= val;
-			*dst++ ^= val;
-			*dst++ ^= val;
-			n -= 4;
-		}
-		while (n--)
-			*dst++ ^= val;
-
-		// Trailing bits
-		if (last)
-			*dst = xor(val, *dst, last);
-	}
-}
-
-static inline void fill_one_line(int bpp, unsigned long next_plane,
-				 unsigned long *dst, int dst_idx, u32 n,
-				 u32 color)
-{
-	while (1) {
-		dst += dst_idx >> SHIFT_PER_LONG;
-		dst_idx &= (BITS_PER_LONG-1);
-		bitfill32(dst, dst_idx, color & 1 ? ~0 : 0, n);
-		if (!--bpp)
-			break;
-		color >>= 1;
-		dst_idx += next_plane*8;
-	}
-}
-
-static inline void xor_one_line(int bpp, unsigned long next_plane,
-				unsigned long *dst, int dst_idx, u32 n,
-				u32 color)
-{
-	while (color) {
-		dst += dst_idx >> SHIFT_PER_LONG;
-		dst_idx &= (BITS_PER_LONG-1);
-		bitxor32(dst, dst_idx, color & 1 ? ~0 : 0, n);
-		if (!--bpp)
-			break;
-		color >>= 1;
-		dst_idx += next_plane*8;
-	}
-}
-
-
 static void atafb_fillrect(struct fb_info *info,
 			   const struct fb_fillrect *rect)
 {
@@ -3419,41 +2799,6 @@
 	return;
 }
 
-static inline void copy_one_line(int bpp, unsigned long next_plane,
-				 unsigned long *dst, int dst_idx,
-				 unsigned long *src, int src_idx, u32 n)
-{
-	while (1) {
-		dst += dst_idx >> SHIFT_PER_LONG;
-		dst_idx &= (BITS_PER_LONG-1);
-		src += src_idx >> SHIFT_PER_LONG;
-		src_idx &= (BITS_PER_LONG-1);
-		bitcpy(dst, dst_idx, src, src_idx, n);
-		if (!--bpp)
-			break;
-		dst_idx += next_plane*8;
-		src_idx += next_plane*8;
-	}
-}
-
-static inline void copy_one_line_rev(int bpp, unsigned long next_plane,
-				     unsigned long *dst, int dst_idx,
-				     unsigned long *src, int src_idx, u32 n)
-{
-	while (1) {
-		dst += dst_idx >> SHIFT_PER_LONG;
-		dst_idx &= (BITS_PER_LONG-1);
-		src += src_idx >> SHIFT_PER_LONG;
-		src_idx &= (BITS_PER_LONG-1);
-		bitcpy_rev(dst, dst_idx, src, src_idx, n);
-		if (!--bpp)
-			break;
-		dst_idx += next_plane*8;
-		src_idx += next_plane*8;
-	}
-}
-
-
 static void atafb_copyarea(struct fb_info *info,
 			   const struct fb_copyarea *area)
 {
@@ -3501,36 +2846,6 @@
 	return;
 }
 
-
-static inline void expand_one_line(int bpp, unsigned long next_plane,
-				   unsigned long *dst, int dst_idx, u32 n,
-				   const u8 *data, u32 bgcolor, u32 fgcolor)
-{
-    const unsigned long *src;
-    int src_idx;
-
-    while (1) {
-	dst += dst_idx >> SHIFT_PER_LONG;
-	dst_idx &= (BITS_PER_LONG-1);
-	if ((bgcolor ^ fgcolor) & 1) {
-	    src = (unsigned long *)((unsigned long)data & ~(BYTES_PER_LONG-1));
-	    src_idx = ((unsigned long)data & (BYTES_PER_LONG-1))*8;
-	    if (fgcolor & 1)
-		bitcpy(dst, dst_idx, src, src_idx, n);
-	    else
-		bitcpy_not(dst, dst_idx, src, src_idx, n);
-	    /* set or clear */
-	} else
-	    bitfill32(dst, dst_idx, fgcolor & 1 ? ~0 : 0, n);
-	if (!--bpp)
-	    break;
-	bgcolor >>= 1;
-	fgcolor >>= 1;
-	dst_idx += next_plane*8;
-    }
-}
-
-
 static void atafb_imageblit(struct fb_info *info, const struct fb_image *image)
 {
 	struct atafb_par *par = (struct atafb_par *)info->par;
@@ -3584,7 +2899,7 @@
 			src += pitch;
 		}
 	} else {
-		// only used for logo
+		// only used for logo; broken
 		c2p(info->screen_base, image->data, dx, dy, width, height,
 		    par->next_line, par->next_plane, image->width,
 		    info->var.bits_per_pixel);
@@ -3738,21 +3053,6 @@
 		default_mem_req=min_mem;
 }
 
-// Obsolete
-static int
-atafb_switch(int con, struct fb_info *info)
-{
-#if 0
-	/* Do we have to save the colormap ? */
-	if (info->cmap.len)
-		fb_get_cmap(info->cmap, 1, fbhw->getcolreg,
-			    info);
-#endif
-	do_fb_set_var(&info->var,1);
-	/* Install new colormap */
-	// do_install_cmap(info);
-	return 0;
-}
 
 int __init atafb_init(void)
 {
