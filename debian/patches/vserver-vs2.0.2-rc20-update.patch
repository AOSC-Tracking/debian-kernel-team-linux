diff -u linux-2.6.16.13-vs2.0.2-rc19/arch/mips/kernel/sysirix.c linux-2.6.16.16-vs2.0.2-rc20/arch/mips/kernel/sysirix.c
--- linux-2.6.16.13-vs2.0.2-rc19/arch/mips/kernel/sysirix.c	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/mips/kernel/sysirix.c	2006-05-11 15:36:52 +0200
@@ -905,7 +905,7 @@
 	down_read(&uts_sem);
 	if (len > __NEW_UTS_LEN)
 		len = __NEW_UTS_LEN;
-	err = copy_to_user(name, system_utsname.domainname, len) ? -EFAULT : 0;
+	err = copy_to_user(name, vx_new_uts(domainname), len) ? -EFAULT : 0;
 	up_read(&uts_sem);
 
 	return err;
@@ -1148,11 +1148,11 @@
 asmlinkage int irix_uname(struct iuname __user *buf)
 {
 	down_read(&uts_sem);
-	if (copy_from_user(system_utsname.sysname, buf->sysname, 65)
-	    || copy_from_user(system_utsname.nodename, buf->nodename, 65)
-	    || copy_from_user(system_utsname.release, buf->release, 65)
-	    || copy_from_user(system_utsname.version, buf->version, 65)
-	    || copy_from_user(system_utsname.machine, buf->machine, 65)) {
+	if (copy_from_user(vx_new_uts(sysname), buf->sysname, 65)
+	    || copy_from_user(vx_new_uts(nodename), buf->nodename, 65)
+	    || copy_from_user(vx_new_uts(release), buf->release, 65)
+	    || copy_from_user(vx_new_uts(version), buf->version, 65)
+	    || copy_from_user(vx_new_uts(machine), buf->machine, 65)) {
 		return -EFAULT;
 	}
 	up_read(&uts_sem);
diff -u linux-2.6.16.13-vs2.0.2-rc19/fs/binfmt_elf.c linux-2.6.16.16-vs2.0.2-rc20/fs/binfmt_elf.c
--- linux-2.6.16.13-vs2.0.2-rc19/fs/binfmt_elf.c	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/fs/binfmt_elf.c	2006-05-11 15:36:52 +0200
@@ -39,6 +39,7 @@
 #include <linux/syscalls.h>
 #include <linux/random.h>
 #include <linux/vs_memory.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
diff -u linux-2.6.16.13-vs2.0.2-rc19/fs/exec.c linux-2.6.16.16-vs2.0.2-rc20/fs/exec.c
--- linux-2.6.16.13-vs2.0.2-rc19/fs/exec.c	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/fs/exec.c	2006-05-11 15:36:52 +0200
@@ -50,6 +50,7 @@
 #include <linux/acct.h>
 #include <linux/cn_proc.h>
 #include <linux/vs_memory.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1334,7 +1335,7 @@
 			case 'h':
 				down_read(&uts_sem);
 				rc = snprintf(out_ptr, out_end - out_ptr,
-					      "%s", system_utsname.nodename);
+					      "%s", vx_new_uts(nodename));
 				up_read(&uts_sem);
 				if (rc > out_end - out_ptr)
 					goto out;
diff -u linux-2.6.16.13-vs2.0.2-rc19/fs/locks.c linux-2.6.16.16-vs2.0.2-rc20/fs/locks.c
--- linux-2.6.16.13-vs2.0.2-rc19/fs/locks.c	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/fs/locks.c	2006-05-11 15:36:16 +0200
@@ -159,12 +159,13 @@
 /* Free a lock which is not in use. */
 static void locks_free_lock(struct file_lock *fl)
 {
-	vx_locks_dec(fl);
-
 	if (fl == NULL) {
 		BUG();
 		return;
 	}
+
+	vx_locks_dec(fl);
+
 	if (waitqueue_active(&fl->fl_wait))
 		panic("Attempting to free lock with active wait queue");
 
@@ -450,6 +451,7 @@
 
 	fl->fl_owner = current->files;
 	fl->fl_pid = current->tgid;
+	fl->fl_xid = vx_current_xid();
 
 	fl->fl_file = filp;
 	fl->fl_flags = FL_LEASE;
diff -u linux-2.6.16.13-vs2.0.2-rc19/include/asm-i386/elf.h linux-2.6.16.16-vs2.0.2-rc20/include/asm-i386/elf.h
--- linux-2.6.16.13-vs2.0.2-rc19/include/asm-i386/elf.h	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/include/asm-i386/elf.h	2006-05-11 15:36:52 +0200
@@ -108,7 +108,7 @@
    For the moment, we have only optimizations for the Intel generations,
    but that could change... */
 
-#define ELF_PLATFORM  (system_utsname.machine)
+#define ELF_PLATFORM  (vx_new_uts(machine))
 
 #ifdef __KERNEL__
 #define SET_PERSONALITY(ex, ibcs2) do { } while (0)
diff -u linux-2.6.16.13-vs2.0.2-rc19/include/net/route.h linux-2.6.16.16-vs2.0.2-rc20/include/net/route.h
--- linux-2.6.16.13-vs2.0.2-rc19/include/net/route.h	2006-04-26 19:12:32 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/include/net/route.h	2006-05-11 18:47:46 +0200
@@ -229,8 +229,10 @@
 			return err;
 		if (fl.fl4_dst == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
 			fl.fl4_dst = nx_info->ipv4[0];
+#ifdef VSERVER_REMAP_SADDR
 		if (fl.fl4_src == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
 			fl.fl4_src = nx_info->ipv4[0];
+#endif
 	}
 	if (!fl.fl4_dst || !fl.fl4_src) {
 		err = __ip_route_output_key(rp, &fl);
diff -u linux-2.6.16.13-vs2.0.2-rc19/kernel/vserver/Kconfig linux-2.6.16.16-vs2.0.2-rc20/kernel/vserver/Kconfig
--- linux-2.6.16.13-vs2.0.2-rc19/kernel/vserver/Kconfig	2006-04-26 19:07:50 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/kernel/vserver/Kconfig	2006-05-11 18:44:37 +0200
@@ -38,6 +38,15 @@
 	  by the chbind tool. Do not disable it unless you exactly
 	  know what you are doing.
 
+config	VSERVER_REMAP_SADDR
+	bool	"Remap Source IP Address"
+	depends on EXPERIMENTAL && !VSERVER_LEGACY
+	default n
+	help
+	  This allows to remap the source IP address of 'local'
+	  connections from 127.0.0.1 to the first assigned
+	  guest IP.
+
 config	VSERVER_PROC_SECURE
 	bool	"Enable Proc Security"
 	depends on PROC_FS
diff -u linux-2.6.16.13-vs2.0.2-rc19/net/ipv4/udp.c linux-2.6.16.16-vs2.0.2-rc20/net/ipv4/udp.c
--- linux-2.6.16.13-vs2.0.2-rc19/net/ipv4/udp.c	2006-04-26 19:08:56 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/net/ipv4/udp.c	2006-05-11 18:49:21 +0200
@@ -617,6 +617,10 @@
 				goto out;
 			if (daddr == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
 				daddr = fl.fl4_dst = nxi->ipv4[0];
+#ifdef VSERVER_REMAP_SADDR
+			if (saddr == IPI_LOOPBACK && !vx_check(0, VX_ADMIN))
+				saddr = fl.fl4_src = nxi->ipv4[0];
+#endif
 		}
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/alpha/kernel/osf_sys.c	2006-02-15 13:54:10 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/alpha/kernel/osf_sys.c	2006-05-11 15:36:52 +0200
@@ -38,6 +38,7 @@
 #include <linux/uio.h>
 #include <linux/vfs.h>
 #include <linux/rcupdate.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/fpu.h>
 #include <asm/io.h>
@@ -399,18 +400,20 @@ asmlinkage int
 osf_utsname(char __user *name)
 {
 	int error;
+	struct new_utsname *ptr;
 
 	down_read(&uts_sem);
+	ptr = vx_new_utsname();
 	error = -EFAULT;
-	if (copy_to_user(name + 0, system_utsname.sysname, 32))
+	if (copy_to_user(name + 0, ptr->sysname, 32))
 		goto out;
-	if (copy_to_user(name + 32, system_utsname.nodename, 32))
+	if (copy_to_user(name + 32, ptr->nodename, 32))
 		goto out;
-	if (copy_to_user(name + 64, system_utsname.release, 32))
+	if (copy_to_user(name + 64, ptr->release, 32))
 		goto out;
-	if (copy_to_user(name + 96, system_utsname.version, 32))
+	if (copy_to_user(name + 96, ptr->version, 32))
 		goto out;
-	if (copy_to_user(name + 128, system_utsname.machine, 32))
+	if (copy_to_user(name + 128, ptr->machine, 32))
 		goto out;
 
 	error = 0;
@@ -439,6 +442,7 @@ osf_getdomainname(char __user *name, int
 {
 	unsigned len;
 	int i;
+	char *domainname;
 
 	if (!access_ok(VERIFY_WRITE, name, namelen))
 		return -EFAULT;
@@ -448,9 +452,10 @@ osf_getdomainname(char __user *name, int
 		len = 32;
 
 	down_read(&uts_sem);
+	domainname = vx_new_uts(domainname);
 	for (i = 0; i < len; ++i) {
-		__put_user(system_utsname.domainname[i], name + i);
-		if (system_utsname.domainname[i] == '\0')
+		__put_user(domainname[i], name + i);
+		if (domainname[i] == '\0')
 			break;
 	}
 	up_read(&uts_sem);
@@ -607,17 +612,6 @@ osf_sigstack(struct sigstack __user *uss
 asmlinkage long
 osf_sysinfo(int command, char __user *buf, long count)
 {
-	static char * sysinfo_table[] = {
-		system_utsname.sysname,
-		system_utsname.nodename,
-		system_utsname.release,
-		system_utsname.version,
-		system_utsname.machine,
-		"alpha",	/* instruction set architecture */
-		"dummy",	/* hardware serial number */
-		"dummy",	/* hardware manufacturer */
-		"dummy",	/* secure RPC domain */
-	};
 	unsigned long offset;
 	char *res;
 	long len, err = -EINVAL;
@@ -630,7 +624,18 @@ osf_sysinfo(int command, char __user *bu
 	}
 	
 	down_read(&uts_sem);
-	res = sysinfo_table[offset];
+	switch (offset)
+	{
+	case 0:	res = vx_new_uts(sysname);  break;
+	case 1:	res = vx_new_uts(nodename); break;
+	case 2:	res = vx_new_uts(release);  break;
+	case 3:	res = vx_new_uts(version);  break;
+	case 4: res = vx_new_uts(machine);  break;
+	case 5:	res = "alpha";              break;
+	default:
+		res = "dummy";
+		break;
+	}
 	len = strlen(res)+1;
 	if (len > count)
 		len = count;
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/m32r/kernel/sys_m32r.c	2006-04-09 13:49:43 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/m32r/kernel/sys_m32r.c	2006-05-11 15:36:52 +0200
@@ -21,6 +21,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/cachectl.h>
@@ -206,7 +207,7 @@ asmlinkage int sys_uname(struct old_utsn
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/parisc/hpux/sys_hpux.c	2006-02-15 13:54:11 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/parisc/hpux/sys_hpux.c	2006-05-11 15:36:52 +0200
@@ -33,6 +33,7 @@
 #include <linux/utsname.h>
 #include <linux/vfs.h>
 #include <linux/vmalloc.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/errno.h>
 #include <asm/pgalloc.h>
@@ -266,15 +267,15 @@ static int hpux_uname(struct hpux_utsnam
 
 	down_read(&uts_sem);
 
-	error = __copy_to_user(&name->sysname,&system_utsname.sysname,HPUX_UTSLEN-1);
+	error = __copy_to_user(&name->sysname,vx_new_uts(sysname),HPUX_UTSLEN-1);
 	error |= __put_user(0,name->sysname+HPUX_UTSLEN-1);
-	error |= __copy_to_user(&name->nodename,&system_utsname.nodename,HPUX_UTSLEN-1);
+	error |= __copy_to_user(&name->nodename,vx_new_uts(nodename),HPUX_UTSLEN-1);
 	error |= __put_user(0,name->nodename+HPUX_UTSLEN-1);
-	error |= __copy_to_user(&name->release,&system_utsname.release,HPUX_UTSLEN-1);
+	error |= __copy_to_user(&name->release,vx_new_uts(release),HPUX_UTSLEN-1);
 	error |= __put_user(0,name->release+HPUX_UTSLEN-1);
-	error |= __copy_to_user(&name->version,&system_utsname.version,HPUX_UTSLEN-1);
+	error |= __copy_to_user(&name->version,vx_new_uts(version),HPUX_UTSLEN-1);
 	error |= __put_user(0,name->version+HPUX_UTSLEN-1);
-	error |= __copy_to_user(&name->machine,&system_utsname.machine,HPUX_UTSLEN-1);
+	error |= __copy_to_user(&name->machine,vx_new_uts(machine),HPUX_UTSLEN-1);
 	error |= __put_user(0,name->machine+HPUX_UTSLEN-1);
 
 	up_read(&uts_sem);
@@ -373,8 +374,8 @@ int hpux_utssys(char *ubuf, int n, int t
 		/*  TODO:  print a warning about using this?  */
 		down_write(&uts_sem);
 		error = -EFAULT;
-		if (!copy_from_user(system_utsname.sysname, ubuf, len)) {
-			system_utsname.sysname[len] = 0;
+		if (!copy_from_user(vx_new_uts(sysname), ubuf, len)) {
+			vx_new_uts(sysname)[len] = 0;
 			error = 0;
 		}
 		up_write(&uts_sem);
@@ -400,8 +401,8 @@ int hpux_utssys(char *ubuf, int n, int t
 		/*  TODO:  print a warning about this?  */
 		down_write(&uts_sem);
 		error = -EFAULT;
-		if (!copy_from_user(system_utsname.release, ubuf, len)) {
-			system_utsname.release[len] = 0;
+		if (!copy_from_user(vx_new_uts(release), ubuf, len)) {
+			vx_new_uts(release)[len] = 0;
 			error = 0;
 		}
 		up_write(&uts_sem);
@@ -422,13 +423,13 @@ int hpux_getdomainname(char *name, int l
  	
  	down_read(&uts_sem);
  	
-	nlen = strlen(system_utsname.domainname) + 1;
+	nlen = strlen(vx_new_uts(domainname)) + 1;
 
 	if (nlen < len)
 		len = nlen;
 	if(len > __NEW_UTS_LEN)
 		goto done;
-	if(copy_to_user(name, system_utsname.domainname, len))
+	if(copy_to_user(name, vx_new_uts(domainname), len))
 		goto done;
 	err = 0;
 done:
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sh/kernel/setup.c	2006-02-15 13:54:12 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sh/kernel/setup.c	2006-05-11 15:36:52 +0200
@@ -20,6 +20,7 @@
 #include <linux/root_dev.h>
 #include <linux/utsname.h>
 #include <linux/cpu.h>
+#include <linux/vs_cvirt.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sections.h>
@@ -485,7 +486,7 @@ static int show_cpuinfo(struct seq_file 
 		seq_printf(m, "machine\t\t: %s\n", get_system_type());
 
 	seq_printf(m, "processor\t: %d\n", cpu);
-	seq_printf(m, "cpu family\t: %s\n", system_utsname.machine);
+	seq_printf(m, "cpu family\t: %s\n", vx_new_uts(machine));
 	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype());
 
 	show_cpuflags(m);
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sh/kernel/sys_sh.c	2005-08-29 22:24:55 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sh/kernel/sys_sh.c	2006-05-11 15:36:52 +0200
@@ -21,6 +21,7 @@
 #include <linux/mman.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
@@ -267,7 +268,7 @@ asmlinkage int sys_uname(struct old_utsn
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sh64/kernel/sys_sh64.c	2005-06-22 02:37:59 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sh64/kernel/sys_sh64.c	2006-05-11 15:36:52 +0200
@@ -29,6 +29,7 @@
 #include <linux/file.h>
 #include <linux/utsname.h>
 #include <linux/syscalls.h>
+#include <linux/vs_cvirt.h>
 #include <asm/uaccess.h>
 #include <asm/ipc.h>
 #include <asm/ptrace.h>
@@ -279,7 +280,7 @@ asmlinkage int sys_uname(struct old_utsn
 	if (!name)
 		return -EFAULT;
 	down_read(&uts_sem);
-	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	err=copy_to_user(name, vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	return err?-EFAULT:0;
 }
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sparc/kernel/sys_sunos.c	2006-02-15 13:54:13 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sparc/kernel/sys_sunos.c	2006-05-11 15:36:52 +0200
@@ -35,6 +35,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/syscalls.h>
+#include <linux/vs_cvirt.h>
 
 #include <net/sock.h>
 
@@ -482,14 +483,16 @@ struct sunos_utsname {
 asmlinkage int sunos_uname(struct sunos_utsname __user *name)
 {
 	int ret;
+	struct new_utsname *ptr;
 	down_read(&uts_sem);
-	ret = copy_to_user(&name->sname[0], &system_utsname.sysname[0], sizeof(name->sname) - 1);
+	ptr = vx_new_utsname();
+	ret = copy_to_user(&name->sname[0], ptr->sysname, sizeof(name->sname) - 1);
 	if (!ret) {
-		ret |= __copy_to_user(&name->nname[0], &system_utsname.nodename[0], sizeof(name->nname) - 1);
+		ret |= __copy_to_user(&name->nname[0], ptr->nodename, sizeof(name->nname) - 1);
 		ret |= __put_user('\0', &name->nname[8]);
-		ret |= __copy_to_user(&name->rel[0], &system_utsname.release[0], sizeof(name->rel) - 1);
-		ret |= __copy_to_user(&name->ver[0], &system_utsname.version[0], sizeof(name->ver) - 1);
-		ret |= __copy_to_user(&name->mach[0], &system_utsname.machine[0], sizeof(name->mach) - 1);
+		ret |= __copy_to_user(&name->rel[0], ptr->release, sizeof(name->rel) - 1);
+		ret |= __copy_to_user(&name->ver[0], ptr->version, sizeof(name->ver) - 1);
+		ret |= __copy_to_user(&name->mach[0], ptr->machine, sizeof(name->mach) - 1);
 	}
 	up_read(&uts_sem);
 	return ret ? -EFAULT : 0;
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sparc64/kernel/sys_sunos32.c	2006-02-15 13:54:13 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sparc64/kernel/sys_sunos32.c	2006-05-11 15:36:52 +0200
@@ -35,6 +35,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/syscalls.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/page.h>
@@ -437,18 +438,20 @@ struct sunos_utsname {
 asmlinkage int sunos_uname(struct sunos_utsname __user *name)
 {
 	int ret;
+	struct new_utsname *ptr;
 
 	down_read(&uts_sem);
-	ret = copy_to_user(&name->sname[0], &system_utsname.sysname[0],
+	ptr = vx_new_utsname();
+	ret = copy_to_user(&name->sname[0], ptr->sysname,
 			   sizeof(name->sname) - 1);
-	ret |= copy_to_user(&name->nname[0], &system_utsname.nodename[0],
+	ret |= copy_to_user(&name->nname[0], ptr->nodename,
 			    sizeof(name->nname) - 1);
 	ret |= put_user('\0', &name->nname[8]);
-	ret |= copy_to_user(&name->rel[0], &system_utsname.release[0],
+	ret |= copy_to_user(&name->rel[0], ptr->release,
 			    sizeof(name->rel) - 1);
-	ret |= copy_to_user(&name->ver[0], &system_utsname.version[0],
+	ret |= copy_to_user(&name->ver[0], ptr->version,
 			    sizeof(name->ver) - 1);
-	ret |= copy_to_user(&name->mach[0], &system_utsname.machine[0],
+	ret |= copy_to_user(&name->mach[0], ptr->machine,
 			    sizeof(name->mach) - 1);
 	up_read(&uts_sem);
 	return (ret ? -EFAULT : 0);
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/sparc64/solaris/misc.c	2006-01-03 17:29:19 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/sparc64/solaris/misc.c	2006-05-11 15:36:52 +0200
@@ -17,6 +17,7 @@
 #include <linux/timex.h>
 #include <linux/major.h>
 #include <linux/compat.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/string.h>
@@ -239,7 +240,7 @@ asmlinkage int solaris_utssys(u32 buf, u
 		/* Let's cheat */
 		err  = set_utsfield(v->sysname, "SunOS", 1, 0);
 		down_read(&uts_sem);
-		err |= set_utsfield(v->nodename, system_utsname.nodename,
+		err |= set_utsfield(v->nodename, vx_new_uts(nodename),
 				    1, 1);
 		up_read(&uts_sem);
 		err |= set_utsfield(v->release, "2.6", 0, 0);
@@ -263,7 +264,7 @@ asmlinkage int solaris_utsname(u32 buf)
 	/* Why should we not lie a bit? */
 	down_read(&uts_sem);
 	err  = set_utsfield(v->sysname, "SunOS", 0, 0);
-	err |= set_utsfield(v->nodename, system_utsname.nodename, 1, 1);
+	err |= set_utsfield(v->nodename, vx_new_uts(nodename), 1, 1);
 	err |= set_utsfield(v->release, "5.6", 0, 0);
 	err |= set_utsfield(v->version, "Generic", 0, 0);
 	err |= set_utsfield(v->machine, machine(), 0, 0);
@@ -295,7 +296,7 @@ asmlinkage int solaris_sysinfo(int cmd, 
 	case SI_HOSTNAME:
 		r = buffer + 256;
 		down_read(&uts_sem);
-		for (p = system_utsname.nodename, q = buffer; 
+		for (p = vx_new_uts(nodename), q = buffer;
 		     q < r && *p && *p != '.'; *q++ = *p++);
 		up_read(&uts_sem);
 		*q = 0;
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/um/sys-x86_64/syscalls.c	2006-01-03 17:29:20 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/um/sys-x86_64/syscalls.c	2006-05-11 15:36:52 +0200
@@ -9,6 +9,7 @@
 #include "linux/shm.h"
 #include "linux/utsname.h"
 #include "linux/personality.h"
+#include "linux/vs_cvirt.h"
 #include "asm/uaccess.h"
 #define __FRAME_OFFSETS
 #include "asm/ptrace.h"
@@ -21,7 +22,7 @@ asmlinkage long sys_uname64(struct new_u
 {
 	int err;
 	down_read(&uts_sem);
-	err = copy_to_user(name, &system_utsname, sizeof (*name));
+	err = copy_to_user(name, vx_new_utsname(), sizeof (*name));
 	up_read(&uts_sem);
 	if (personality(current->personality) == PER_LINUX32)
 		err |= copy_to_user(&name->machine, "i686", 5);
only in patch2:
unchanged:
--- linux-2.6.16.16/arch/xtensa/kernel/syscalls.c	2005-08-29 22:24:57 +0200
+++ linux-2.6.16.16-vs2.0.2-rc20/arch/xtensa/kernel/syscalls.c	2006-05-11 15:36:52 +0200
@@ -35,6 +35,7 @@
 #include <linux/msg.h>
 #include <linux/shm.h>
 #include <linux/errno.h>
+#include <linux/vs_cvirt.h>
 #include <asm/ptrace.h>
 #include <asm/signal.h>
 #include <asm/uaccess.h>
@@ -129,7 +130,7 @@ out:
 
 int sys_uname(struct old_utsname * name)
 {
-	if (name && !copy_to_user(name, &system_utsname, sizeof (*name)))
+	if (name && !copy_to_user(name, vx_new_utsname(), sizeof (*name)))
 		return 0;
 	return -EFAULT;
 }
only in patch2:
unchanged:
--- linux-2.6.16.16/fs/binfmt_elf_fdpic.c	2006-01-18 06:08:29 +0100
+++ linux-2.6.16.16-vs2.0.2-rc20/fs/binfmt_elf_fdpic.c	2006-05-11 15:36:52 +0200
@@ -32,6 +32,7 @@
 #include <linux/elf.h>
 #include <linux/elf-fdpic.h>
 #include <linux/elfcore.h>
+#include <linux/vs_cvirt.h>
 
 #include <asm/uaccess.h>
 #include <asm/param.h>
