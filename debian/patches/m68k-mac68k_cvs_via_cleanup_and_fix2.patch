--- a/arch/m68k/mac/config.c	Tue Jun 28 21:33:48 2005
+++ linux/arch/m68k/mac/config.c	Tue Jun 28 21:35:02 2005
@@ -89,23 +89,10 @@
 
 static void mac_get_model(char *str);
 
-void mac_bang(int irq, void *vector, struct pt_regs *p)
-{
-	printk(KERN_INFO "Resetting ...\n");
-	mac_reset();
-}
-
 static void mac_sched_init(irqreturn_t (*vector)(int, void *, struct pt_regs *))
 {
 	via_init_clock(vector);
 }
-
-#if 0
-void mac_waitbut (void)
-{
-	;
-}
-#endif
 
 extern irqreturn_t mac_default_handler(int, void *, struct pt_regs *);
 
--- a/arch/m68k/mac/macints.c	Tue Jun 28 21:33:48 2005
+++ linux/arch/m68k/mac/macints.c	Tue Jun 28 21:35:02 2005
@@ -216,7 +216,6 @@
  * console_loglevel determines NMI handler function
  */
 
-extern irqreturn_t mac_bang(int, void *, struct pt_regs *);
 irqreturn_t mac_nmi_handler(int, void *, struct pt_regs *);
 irqreturn_t mac_debug_handler(int, void *, struct pt_regs *);
 
--- a/arch/m68k/mac/via.c	Tue Jun 28 21:33:48 2005
+++ linux/arch/m68k/mac/via.c	Wed Jun 29 01:55:05 2005
@@ -25,7 +25,6 @@
 #include <linux/init.h>
 #include <linux/ide.h>
 
-#include <asm/traps.h>
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>
 #include <asm/macints.h>
@@ -71,7 +70,6 @@
 void via_irq_disable(int irq);
 void via_irq_clear(int irq);
 
-extern irqreturn_t mac_bang(int, void *, struct pt_regs *);
 extern irqreturn_t mac_scc_dispatch(int, void *, struct pt_regs *);
 extern int oss_present;
 
@@ -212,11 +210,6 @@
 			break;
 	}
 #else
-	/* The alernate IRQ mapping seems to just not work. Anyone with a   */
-	/* supported machine is welcome to take a stab at fixing it. It     */
-	/* _should_ work on the following Quadras: 610,650,700,800,900,950  */
-	/*                                               - 1999-06-12 (jmt) */
-
 	via_alt_mapping = 0;
 #endif
 
@@ -270,12 +263,6 @@
 		cpu_request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
 				(void *) via1);
-#if 0 /* interferes with serial on some machines */
-		if (!psc_present) {
-			cpu_request_irq(IRQ_AUTO_6, mac_bang, IRQ_FLG_LOCK,
-					"Off Switch", mac_bang);
-		}
-#endif
 	}
 	cpu_request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
 			"via2", (void *) via2);
@@ -471,8 +458,8 @@
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
 		if (events & irq_bit) {
 			via2[gIER] = irq_bit;
-			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
 			via2[gIFR] = irq_bit | rbv_clear;
+			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
 			via2[gIER] = irq_bit | 0x80;
 		}
 	return IRQ_HANDLED;
@@ -529,6 +516,7 @@
 		}
 		via2[gIER] = irq_bit | 0x80;
 	} else if (irq_src == 7) {
+		nubus_active |= irq_bit;
 		if (rbv_present) {
 			/* enable the slot interrupt. SIER works like IER. */
 			via2[rSIER] = IER_SET_BIT(irq_idx);
@@ -550,7 +538,6 @@
 				}
 			}
 		}
-		nubus_active |= irq_bit;
 	}
 }
 
