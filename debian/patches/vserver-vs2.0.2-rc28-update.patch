diff -u linux-2.6.17-vs2.0.2-rc24/arch/v850/kernel/ptrace.c linux-2.6.17.7-vs2.0.2-rc28/arch/v850/kernel/ptrace.c
--- linux-2.6.17-vs2.0.2-rc24/arch/v850/kernel/ptrace.c	2006-06-18 05:02:55 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/arch/v850/kernel/ptrace.c	2006-07-27 19:01:39 +0200
@@ -117,6 +117,9 @@
 {
 	int rval;
 
+	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
+		goto out;
+
 	switch (request) {
 		unsigned long val, copied;
 
@@ -137,8 +140,6 @@
 			break;
 		rval = -EIO;
 		goto out;
-	if (!vx_check(vx_task_xid(child), VX_WATCH|VX_IDENT))
-		goto out_tsk;
 
 	/* Read/write the word at location ADDR in the registers.  */
 	case PTRACE_PEEKUSR:
reverted:
--- linux-2.6.17-vs2.0.2-rc24/fs/dquot.c	2006-06-18 17:37:41 +0200
+++ linux-2.6.17/fs/dquot.c	2006-06-18 04:54:33 +0200
@@ -458,7 +458,6 @@
 	spin_unlock(&dq_list_lock);
 }
 
-
 int vfs_quota_sync(struct super_block *sb, int type)
 {
 	struct list_head *dirty;
@@ -668,6 +667,7 @@
 #ifdef __DQUOT_PARANOIA
 	BUG_ON(!dquot->dq_sb);	/* Has somebody invalidated entry under us? */
 #endif
+
 	return dquot;
 }
 
diff -u linux-2.6.17-vs2.0.2-rc24/fs/namespace.c linux-2.6.17.7-vs2.0.2-rc28/fs/namespace.c
--- linux-2.6.17-vs2.0.2-rc24/fs/namespace.c	2006-06-18 05:28:30 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/fs/namespace.c	2006-08-05 04:03:48 +0200
@@ -449,17 +449,27 @@
 	struct vfsmount *mnt = v;
 	int err = 0;
 
-	/* device */
-	if (mnt->mnt_devname) {
-		seq_puts(m, "device ");
-		mangle(m, mnt->mnt_devname);
-	} else
-		seq_puts(m, "no device");
-
-	/* mount point */
-	seq_puts(m, " mounted on ");
-	seq_path(m, mnt, mnt->mnt_root, " \t\n\\");
-	seq_putc(m, ' ');
+	if (vx_flags(VXF_HIDE_MOUNT, 0))
+		return 0;
+	if (!mnt_is_reachable(mnt) && !vx_check(0, VX_WATCH))
+		return 0;
+
+	if (!vx_check(0, VX_ADMIN|VX_WATCH) &&
+		mnt == current->fs->rootmnt) {
+		seq_puts(m, "device /dev/root mounted on / ");
+	} else {
+		/* device */
+		if (mnt->mnt_devname) {
+			seq_puts(m, "device ");
+			mangle(m, mnt->mnt_devname);
+		} else
+			seq_puts(m, "no device");
+
+		/* mount point */
+		seq_puts(m, " mounted on ");
+		seq_path(m, mnt, mnt->mnt_root, " \t\n\\");
+		seq_putc(m, ' ');
+	}
 
 	/* file system type */
 	seq_puts(m, "with fstype ");
@@ -558,11 +568,15 @@
 	}
 }
 
-static inline void __umount_list(struct vfsmount *mnt,
-	int propagate, struct list_head *kill)
+void umount_tree(struct vfsmount *mnt, int propagate, struct list_head *kill)
 {
 	struct vfsmount *p;
 
+	for (p = mnt; p; p = next_mnt(p, mnt)) {
+		list_del(&p->mnt_hash);
+		list_add(&p->mnt_hash, kill);
+	}
+
 	if (propagate)
 		propagate_umount(kill);
 
@@ -578,33 +592,6 @@
 	}
 }
 
-void umount_tree(struct vfsmount *mnt, int propagate, struct list_head *kill)
-{
-	struct vfsmount *p;
-
-	for (p = mnt; p; p = next_mnt(p, mnt)) {
-		list_del(&p->mnt_hash);
-		list_add(&p->mnt_hash, kill);
-		// p->mnt_namespace = NULL;
-	}
-	__umount_list(mnt, propagate, kill);
-}
-
-void umount_unused(struct vfsmount *mnt, struct fs_struct *fs)
-{
-	struct vfsmount *p;
-	LIST_HEAD(kill);
-
-	for (p = mnt; p; p = next_mnt(p, mnt)) {
-		if (p == fs->rootmnt || p == fs->pwdmnt)
-			continue;
-		list_del(&p->mnt_list);
-		list_add(&p->mnt_list, &kill);
-		p->mnt_namespace = NULL;
-	}
-	__umount_list(mnt, 0, &kill);
-}
-
 static int do_umount(struct vfsmount *mnt, int flags)
 {
 	struct super_block *sb = mnt->mnt_sb;
diff -u linux-2.6.17-vs2.0.2-rc24/include/asm-i386/elf.h linux-2.6.17.7-vs2.0.2-rc28/include/asm-i386/elf.h
--- linux-2.6.17-vs2.0.2-rc24/include/asm-i386/elf.h	2006-06-18 05:03:04 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/include/asm-i386/elf.h	2006-07-27 19:01:39 +0200
@@ -71,7 +71,7 @@
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
-#define ELF_ET_DYN_BASE		((TASK_UNMAPPED_BASE) * 2)
+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)
 
 /* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
    now struct_user_regs, they are different) */
reverted:
--- linux-2.6.17-vs2.0.2-rc24/include/linux/namespace.h	2006-06-18 05:03:04 +0200
+++ linux-2.6.17/include/linux/namespace.h	2006-02-18 14:40:34 +0100
@@ -16,7 +16,6 @@
 extern int copy_namespace(int, struct task_struct *);
 extern void __put_namespace(struct namespace *namespace);
 extern struct namespace *dup_namespace(struct task_struct *, struct fs_struct *);
-extern void umount_unused(struct vfsmount *, struct fs_struct *);
 
 static inline void put_namespace(struct namespace *namespace)
 {
diff -u linux-2.6.17-vs2.0.2-rc24/include/linux/vserver/namespace_cmd.h linux-2.6.17.7-vs2.0.2-rc28/include/linux/vserver/namespace_cmd.h
--- linux-2.6.17-vs2.0.2-rc24/include/linux/vserver/namespace_cmd.h	2006-06-18 05:03:05 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/include/linux/vserver/namespace_cmd.h	2006-07-27 19:01:39 +0200
@@ -3,7 +3,6 @@
 
 
 #define VCMD_enter_namespace	VC_CMD(PROCALT, 1, 0)
-#define VCMD_cleanup_namespace	VC_CMD(PROCALT, 2, 0)
 
 #define VCMD_set_namespace_v0	VC_CMD(PROCALT, 3, 0)
 #define VCMD_set_namespace	VC_CMD(PROCALT, 3, 1)
@@ -12,7 +11,6 @@
 #ifdef	__KERNEL__
 
 extern int vc_enter_namespace(uint32_t, void __user *);
-extern int vc_cleanup_namespace(uint32_t, void __user *);
 extern int vc_set_namespace(uint32_t, void __user *);
 
 #endif	/* __KERNEL__ */
diff -u linux-2.6.17-vs2.0.2-rc24/kernel/exit.c linux-2.6.17.7-vs2.0.2-rc28/kernel/exit.c
--- linux-2.6.17-vs2.0.2-rc24/kernel/exit.c	2006-06-18 05:28:31 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/kernel/exit.c	2006-07-26 21:36:28 +0200
@@ -729,7 +729,6 @@
 	list_for_each_safe(_p, _n, &father->ptrace_children) {
 		p = list_entry(_p,struct task_struct,ptrace_list);
 		/* check for reaper context */
-		BUG_ON(p->xid != reaper->xid);
 		choose_new_parent(p, reaper);
 		reparent_thread(p, father, 1);
 	}
diff -u linux-2.6.17-vs2.0.2-rc24/kernel/sys.c linux-2.6.17.7-vs2.0.2-rc28/kernel/sys.c
--- linux-2.6.17-vs2.0.2-rc24/kernel/sys.c	2006-06-18 05:28:31 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/kernel/sys.c	2006-07-26 21:36:28 +0200
@@ -1698,7 +1698,7 @@
 	int errno;
 	char tmp[__NEW_UTS_LEN];
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!vx_capable(CAP_SYS_ADMIN, VXC_SET_UTSNAME))
 		return -EPERM;
 	if (len < 0 || len > __NEW_UTS_LEN)
 		return -EINVAL;
diff -u linux-2.6.17-vs2.0.2-rc24/kernel/vserver/cvirt.c linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/cvirt.c
--- linux-2.6.17-vs2.0.2-rc24/kernel/vserver/cvirt.c	2006-06-18 05:28:31 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/cvirt.c	2006-07-27 19:45:30 +0200
@@ -68,8 +68,9 @@
 	uint32_t now, last, delta;
 	unsigned int nr_running, nr_uninterruptible;
 	unsigned int total;
+	unsigned long flags;
 
-	spin_lock(&vxi->cvirt.load_lock);
+	spin_lock_irqsave(&vxi->cvirt.load_lock, flags);
 
 	now = jiffies;
 	last = vxi->cvirt.load_last;
@@ -92,7 +93,7 @@
 	vxi->cvirt.load_last = now;
 out:
 	atomic_inc(&vxi->cvirt.load_updates);
-	spin_unlock(&vxi->cvirt.load_lock);
+	spin_unlock_irqrestore(&vxi->cvirt.load_lock, flags);
 }
 
 
diff -u linux-2.6.17-vs2.0.2-rc24/kernel/vserver/namespace.c linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/namespace.c
--- linux-2.6.17-vs2.0.2-rc24/kernel/vserver/namespace.c	2006-06-18 05:28:31 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/namespace.c	2006-07-27 19:01:39 +0200
@@ -85,16 +85,6 @@
 	return ret;
 }
 
-int vc_cleanup_namespace(uint32_t id, void __user *data)
-{
-	// down_write(&current->namespace->sem);
-	spin_lock(&vfsmount_lock);
-	umount_unused(current->namespace->root, current->fs);
-	spin_unlock(&vfsmount_lock);
-	// up_write(&current->namespace->sem);
-	return 0;
-}
-
 int vc_set_namespace(uint32_t id, void __user *data)
 {
 	struct fs_struct *fs;
diff -u linux-2.6.17-vs2.0.2-rc24/kernel/vserver/switch.c linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/switch.c
--- linux-2.6.17-vs2.0.2-rc24/kernel/vserver/switch.c	2006-06-18 05:28:31 +0200
+++ linux-2.6.17.7-vs2.0.2-rc28/kernel/vserver/switch.c	2006-07-27 19:01:39 +0200
@@ -111,8 +111,6 @@
 		return vc_set_namespace(-1, data);
 	case VCMD_set_namespace:
 		return vc_set_namespace(id, data);
-	case VCMD_cleanup_namespace:
-		return vc_cleanup_namespace(id, data);
 	}
 
 	/* those are allowed while in setup too */
