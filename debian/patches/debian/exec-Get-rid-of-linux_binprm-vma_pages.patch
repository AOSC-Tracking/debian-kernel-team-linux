commit 4e23932a029c81d85addac636acce96e9e1f3eab
Author: dann frazier <dann.frazier@canonical.com>
Date:   Wed Jan 12 22:30:18 2011 -0700

    From 5e91f59665165f91f97746439e53cc520bb42b97 Mon Sep 17 00:00:00 2001
    From: Ben Hutchings <ben@decadent.org.uk>
    Date: Mon, 3 Jan 2011 03:31:58 +0000
    Subject: [PATCH] exec: Get rid of linux_binprm::vma_pages
    
    Adding linux_binprm::vma_pages is an ABI-breaker and we can't hide it
    because the structure is allocated directly by modules.  However it's
    just a cache of vma_pages(bprm->vma), so:
    
    - We can work out and pass in the old value from get_arg_page()
    - The calls to acct_arg_size(bprm, 0) are redundant, since
      neither the cache nor the dead mm need to be updated
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    [dannf: Backported to Debian's 2.6.26]

diff --git a/fs/compat.c b/fs/compat.c
index ed8008c..df5361f 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -1415,7 +1415,6 @@ out:
 
 out_mm:
 	if (bprm->mm) {
-		acct_arg_size(bprm, 0);
 		mmput(bprm->mm);
 	}
 
diff --git a/fs/exec.c b/fs/exec.c
index ab1bada..6b7c7dd 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -159,16 +159,15 @@ exit:
 
 #ifdef CONFIG_MMU
 
-void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
+static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages,
+			  unsigned long old_pages)
 {
 	struct mm_struct *mm = current->mm;
-	long diff = (long)(pages - bprm->vma_pages);
+	long diff = (long)(pages - old_pages);
 
 	if (!mm || !diff)
 		return;
 
-	bprm->vma_pages = pages;
-
 	down_write(&mm->mmap_sem);
 	mm->total_vm += diff;
 	up_write(&mm->mmap_sem);
@@ -177,6 +176,8 @@ void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
 struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 		int write)
 {
+	unsigned long old_vma_pages =
+		(bprm->vma->vm_end - bprm->vma->vm_start) / PAGE_SIZE;
 	struct page *page;
 	int ret;
 
@@ -196,7 +197,7 @@ struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;
 		struct rlimit *rlim;
 
-		acct_arg_size(bprm, size / PAGE_SIZE);
+		acct_arg_size(bprm, size / PAGE_SIZE, old_vma_pages);
 
 		/*
 		 * We've historically supported up to 32 pages (ARG_MAX)
@@ -294,7 +295,8 @@ static bool valid_arg_len(struct linux_binprm *bprm, long len)
 
 #else
 
-void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)
+static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages,
+			  unsigned long old_pages)
 {
 }
 
@@ -988,7 +990,6 @@ int flush_old_exec(struct linux_binprm * bprm)
 	/*
 	 * Release all of the old mmap stuff
 	 */
-	acct_arg_size(bprm, 0);
 	retval = exec_mmap(bprm->mm);
 	if (retval)
 		goto out;
@@ -1379,7 +1380,6 @@ out:
 
 out_mm:
 	if (bprm->mm) {
-		acct_arg_size(bprm, 0);
 		mmput(bprm->mm);
 	}
 
diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h
index b7b836e..ffb7f1a 100644
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@ -28,7 +28,6 @@ struct linux_binprm{
 	char buf[BINPRM_BUF_SIZE];
 #ifdef CONFIG_MMU
 	struct vm_area_struct *vma;
-	unsigned long vma_pages;
 #else
 # define MAX_ARG_PAGES	32
 	struct page *page[MAX_ARG_PAGES];
@@ -52,7 +51,6 @@ struct linux_binprm{
 	unsigned long loader, exec;
 };
 
-extern void acct_arg_size(struct linux_binprm *bprm, unsigned long pages);
 extern struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,
 					int write);
 
