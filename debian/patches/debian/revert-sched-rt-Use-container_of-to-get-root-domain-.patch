From 894708eaeb785463cc13bd7cc0f39cd9a0a3db05 Mon Sep 17 00:00:00 2001
From: Yves-Alexis Perez <corsac@debian.org>
Date: Sat, 17 Feb 2018 15:43:35 +0100
Subject: [PATCH] Revert "sched/rt: Use container_of() to get root domain in rto_push_irq_work_func()"
Forwarded: Not needed

This reverts commit 1c679981309b4d36b024fc954cfcf2111a007de0 which is
commit ad0f1d9d65938aec72a698116cd73a980916895e upstream. It has to be
applied on top of 1c37ff78298a6b6063649123356a312e1cce12ca which has
been reverted in Debian to prevent an ABI change.
---
 kernel/sched/rt.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index f6d68ddfa2f3..30aeff8f741c 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -1895,8 +1895,9 @@ static void push_rt_tasks(struct rq *rq)
  * the rt_loop_next will cause the iterator to perform another scan.
  *
  */
-static int rto_next_cpu(struct root_domain *rd)
+static int rto_next_cpu(struct rq *rq)
 {
+	struct root_domain *rd = rq->rd;
 	int next;
 	int cpu;
 
@@ -1972,7 +1973,7 @@ static void tell_cpu_to_push(struct rq *rq)
 	 * Otherwise it is finishing up and an ipi needs to be sent.
 	 */
 	if (rq->rd->rto_cpu < 0)
-		cpu = rto_next_cpu(rq->rd);
+		cpu = rto_next_cpu(rq);
 
 	raw_spin_unlock(&rq->rd->rto_lock);
 
@@ -1988,8 +1989,6 @@ static void tell_cpu_to_push(struct rq *rq)
 /* Called from hardirq context */
 void rto_push_irq_work_func(struct irq_work *work)
 {
-	struct root_domain *rd =
-		container_of(work, struct root_domain, rto_push_work);
 	struct rq *rq;
 	int cpu;
 
@@ -2005,12 +2004,12 @@ void rto_push_irq_work_func(struct irq_work *work)
 		raw_spin_unlock(&rq->lock);
 	}
 
-	raw_spin_lock(&rd->rto_lock);
+	raw_spin_lock(&rq->rd->rto_lock);
 
 	/* Pass the IPI to the next rt overloaded queue */
-	cpu = rto_next_cpu(rd);
+	cpu = rto_next_cpu(rq);
 
-	raw_spin_unlock(&rd->rto_lock);
+	raw_spin_unlock(&rq->rd->rto_lock);
 
 	if (cpu < 0) {
 		sched_put_rd(rd);
@@ -2018,7 +2017,7 @@ void rto_push_irq_work_func(struct irq_work *work)
 	}
 
 	/* Try the next RT overloaded CPU */
-	irq_work_queue_on(&rd->rto_push_work, cpu);
+	irq_work_queue_on(&rq->rd->rto_push_work, cpu);
 }
 #endif /* HAVE_RT_PUSH_IPI */
 
-- 
2.16.1

