From: Ben Hutchings <ben@decadent.org.uk>
Date: Mon, 17 Jul 2017 19:11:49 +0100
Subject: firmware: dmi: Avoid ABI break for DMI_PRODUCT_FAMILY
Forwarded: not-needed
Bug-Debian: https://bugs.debian.org/862723

The DMI API in Linux uses its own enumeration of field IDs (rather
than the numbers used in DMI) and uses them as indices into the
static dmi_ident array without range-checking.  So adding
DMI_PRODUCT_FAMILY to this enumeration is a real ABI change.

However, we can make this a compatible extension to the ABI by:
(1) adding the new enumerator at the end, avoiding renumbering;
(2) adding range checks to the functions that access dmi_ident;
(3) renaming (with #define) all the affected functions, so that
    any modules built against the new definition will fail to
    load on old kernel versions;
(4) adding trivial wrappers under the old names.

Step (2) allows further additions without any more code changes.

---
--- a/include/linux/dmi.h
+++ b/include/linux/dmi.h
@@ -96,20 +96,25 @@ struct dmi_dev_onboard {
 };
 
 extern struct kobject *dmi_kobj;
+#define dmi_check_system dmi_check_system_safe
 extern int dmi_check_system(const struct dmi_system_id *list);
+#define dmi_first_match dmi_first_match_safe
 const struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list);
+#define dmi_get_system_info dmi_get_system_info_safe
 extern const char * dmi_get_system_info(int field);
 extern const struct dmi_device * dmi_find_device(int type, const char *name,
 	const struct dmi_device *from);
 extern void dmi_scan_machine(void);
 extern void dmi_memdev_walk(void);
 extern void dmi_set_dump_stack_arch_desc(void);
+#define dmi_get_date dmi_get_date_safe
 extern bool dmi_get_date(int field, int *yearp, int *monthp, int *dayp);
 extern int dmi_name_in_vendors(const char *str);
 extern int dmi_name_in_serial(const char *str);
 extern int dmi_available;
 extern int dmi_walk(void (*decode)(const struct dmi_header *, void *),
 	void *private_data);
+#define dmi_match dmi_match_safe
 extern bool dmi_match(enum dmi_field f, const char *str);
 extern void dmi_memdev_name(u16 handle, const char **bank, const char **device);
 
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -456,7 +456,6 @@ enum dmi_field {
 	DMI_PRODUCT_VERSION,
 	DMI_PRODUCT_SERIAL,
 	DMI_PRODUCT_UUID,
-	DMI_PRODUCT_FAMILY,
 	DMI_BOARD_VENDOR,
 	DMI_BOARD_NAME,
 	DMI_BOARD_VERSION,
@@ -467,6 +466,9 @@ enum dmi_field {
 	DMI_CHASSIS_VERSION,
 	DMI_CHASSIS_SERIAL,
 	DMI_CHASSIS_ASSET_TAG,
+#ifndef __GENKSYMS__
+	DMI_PRODUCT_FAMILY,
+#endif
 	DMI_STRING_MAX,
 };
 
--- a/drivers/firmware/dmi_scan.c
+++ b/drivers/firmware/dmi_scan.c
@@ -766,7 +766,7 @@ static bool dmi_matches(const struct dmi
 		int s = dmi->matches[i].slot;
 		if (s == DMI_NONE)
 			break;
-		if (dmi_ident[s]) {
+		if (s < DMI_STRING_MAX && dmi_ident[s]) {
 			if (!dmi->matches[i].exact_match &&
 			    strstr(dmi_ident[s], dmi->matches[i].substr))
 				continue;
@@ -852,7 +852,7 @@ EXPORT_SYMBOL(dmi_first_match);
  */
 const char *dmi_get_system_info(int field)
 {
-	return dmi_ident[field];
+	return field < DMI_STRING_MAX ? dmi_ident[field] : NULL;
 }
 EXPORT_SYMBOL(dmi_get_system_info);
 
@@ -1048,3 +1048,38 @@ void dmi_memdev_name(u16 handle, const c
 	}
 }
 EXPORT_SYMBOL_GPL(dmi_memdev_name);
+
+#undef dmi_check_system
+int dmi_check_system(const struct dmi_system_id *list)
+{
+	return dmi_check_system_safe(list);
+}
+EXPORT_SYMBOL(dmi_check_system);
+
+#undef dmi_first_match
+const struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list)
+{
+	return dmi_first_match_safe(list);
+}
+EXPORT_SYMBOL(dmi_first_match);
+
+#undef dmi_get_system_info
+const char *dmi_get_system_info(int field)
+{
+	return dmi_get_system_info_safe(field);
+}
+EXPORT_SYMBOL(dmi_get_system_info);
+
+#undef dmi_get_date
+bool dmi_get_date(int field, int *yearp, int *monthp, int *dayp)
+{
+	return dmi_get_date_safe(field, yearp, monthp, dayp);
+}
+EXPORT_SYMBOL(dmi_get_date);
+
+#undef dmi_match
+bool dmi_match(enum dmi_field f, const char *str)
+{
+	return dmi_match_safe(f, str);
+}
+EXPORT_SYMBOL_GPL(dmi_match);
