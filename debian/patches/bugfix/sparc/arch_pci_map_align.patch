commit 5769907ade8dda7002b304c03ef9e4ee5c1e0821
Author: Max Dmitrichenko <dmitrmax@gmail.com>
Date:   Sun Nov 2 00:34:10 2008 -0700

    sparc64: Fix PCI resource mapping on sparc64
    
    There is a problem discovered in recent versions of ATI Mach64 driver
    in X.org on sparc64 architecture. In short, the driver fails to mmap
    MMIO aperture (PCI resource #2).
    
    I've found that kernel's __pci_mmap_make_offset() returns EINVAL. It
    checks whether user attempts to mmap more than the resource length,
    which is 0x1000 bytes in our case. But PAGE_SIZE on SPARC64 is 0x2000
    and this is what actually is being mmaped. So __pci_mmap_make_offset()
    failed for this PCI resource.
    
    Signed-off-by: Max Dmitrichenko <dmitrmax@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc64/kernel/pci.c b/arch/sparc64/kernel/pci.c
index 242ac1c..bdb7c0a 100644
--- a/arch/sparc64/kernel/pci.c
+++ b/arch/sparc64/kernel/pci.c
@@ -889,6 +889,7 @@ static int __pci_mmap_make_offset(struct pci_dev *pdev,
 
 	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
 		struct resource *rp = &pdev->resource[i];
+		resource_size_t aligned_end;
 
 		/* Active? */
 		if (!rp->flags)
@@ -906,8 +907,15 @@ static int __pci_mmap_make_offset(struct pci_dev *pdev,
 				continue;
 		}
 
+		/* Align the resource end to the next page address.
+		 * PAGE_SIZE intentionally added instead of (PAGE_SIZE - 1),
+		 * because actually we need the address of the next byte
+		 * after rp->end.
+		 */
+		aligned_end = (rp->end + PAGE_SIZE) & PAGE_MASK;
+
 		if ((rp->start <= user_paddr) &&
-		    (user_paddr + user_size) <= (rp->end + 1UL))
+		    (user_paddr + user_size) <= aligned_end)
 			break;
 	}
 
