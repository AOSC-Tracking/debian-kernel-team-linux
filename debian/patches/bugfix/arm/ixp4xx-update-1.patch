diff --git a/arch/arm/mach-ixp4xx/nas100d-setup.c b/arch/arm/mach-ixp4xx/nas100d-setup.c
index 39d7d90..2cbcd41 100644
--- a/arch/arm/mach-ixp4xx/nas100d-setup.c
+++ b/arch/arm/mach-ixp4xx/nas100d-setup.c
@@ -12,6 +12,7 @@
  *
  */
 
+#include <linux/if_ether.h>
 #include <linux/kernel.h>
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
@@ -165,6 +166,7 @@ static void nas100d_power_off(void)
 
 static void __init nas100d_init(void)
 {
+	DECLARE_MAC_BUF(mac_buf);
 	uint8_t __iomem *f;
 	int i;
 
@@ -188,32 +190,23 @@ static void __init nas100d_init(void)
 
 	platform_add_devices(nas100d_devices, ARRAY_SIZE(nas100d_devices));
 
-
 	/*
 	 * Map in a portion of the flash and read the MAC address.
 	 * Since it is stored in BE in the flash itself, we need to
 	 * byteswap it if we're in LE mode.
 	 */
-	if ((f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x1000000))) {
+	f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x1000000);
+	if (f) {
+		for (i = 0; i < 6; i++)
 #ifdef __ARMEB__
-		for (i = 0; i < 6; i++) {
 			nas100d_plat_eth[0].hwaddr[i] = readb(f + 0xFC0FD8 + i);
-		}
 #else
-		nas100d_plat_eth[0].hwaddr[0] = readb(f + 0xFC0FD8 + 3);
-		nas100d_plat_eth[0].hwaddr[1] = readb(f + 0xFC0FD8 + 2);
-		nas100d_plat_eth[0].hwaddr[2] = readb(f + 0xFC0FD8 + 1);
-		nas100d_plat_eth[0].hwaddr[3] = readb(f + 0xFC0FD8 + 0);
-		nas100d_plat_eth[0].hwaddr[4] = readb(f + 0xFC0FD8 + 7);
-		nas100d_plat_eth[0].hwaddr[5] = readb(f + 0xFC0FD8 + 6);
+			nas100d_plat_eth[0].hwaddr[i] = readb(f + 0xFC0FD8 + (i^3));
 #endif
 		iounmap(f);
 	}
-	printk(KERN_INFO "NAS100D: Using MAC address %.2x:%.2x:%.2x:%.2x:%.2x:%.2x for port 0\n",
-	       nas100d_plat_eth[0].hwaddr[0], nas100d_plat_eth[0].hwaddr[1],
-	       nas100d_plat_eth[0].hwaddr[2], nas100d_plat_eth[0].hwaddr[3],
-	       nas100d_plat_eth[0].hwaddr[4], nas100d_plat_eth[0].hwaddr[5]);
-
+	printk(KERN_INFO "NAS100D: Using MAC address %s for port 0\n",
+		print_mac(mac_buf, nas100d_plat_eth[0].hwaddr));
 }
 
 MACHINE_START(NAS100D, "Iomega NAS 100d")
diff --git a/arch/arm/mach-ixp4xx/nslu2-setup.c b/arch/arm/mach-ixp4xx/nslu2-setup.c
index f5e9cf7..fcd4fa6 100644
--- a/arch/arm/mach-ixp4xx/nslu2-setup.c
+++ b/arch/arm/mach-ixp4xx/nslu2-setup.c
@@ -14,6 +14,7 @@
  * Changed to conform to new style __init ixdp425 kas11 10/22/04
  */
 
+#include <linux/if_ether.h>
 #include <linux/kernel.h>
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
@@ -194,6 +195,7 @@ static struct sys_timer nslu2_timer = {
 
 static void __init nslu2_init(void)
 {
+	DECLARE_MAC_BUF(mac_buf);
 	uint8_t __iomem *f;
 	int i;
 
@@ -214,31 +216,23 @@ static void __init nslu2_init(void)
 
 	platform_add_devices(nslu2_devices, ARRAY_SIZE(nslu2_devices));
 
-
 	/*
 	 * Map in a portion of the flash and read the MAC address.
 	 * Since it is stored in BE in the flash itself, we need to
 	 * byteswap it if we're in LE mode.
 	 */
-	if ((f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x40000))) {
+	f = ioremap(IXP4XX_EXP_BUS_BASE(0), 0x40000);
+	if (f) {
+		for (i = 0; i < 6; i++)
 #ifdef __ARMEB__
-		for (i = 0; i < 6; i++) {
 			nslu2_plat_eth[0].hwaddr[i] = readb(f + 0x3FFB0 + i);
-		}
 #else
-		nslu2_plat_eth[0].hwaddr[0] = readb(f + 0x3FFB0 + 3);
-		nslu2_plat_eth[0].hwaddr[1] = readb(f + 0x3FFB0 + 2);
-		nslu2_plat_eth[0].hwaddr[2] = readb(f + 0x3FFB0 + 1);
-		nslu2_plat_eth[0].hwaddr[3] = readb(f + 0x3FFB0 + 0);
-		nslu2_plat_eth[0].hwaddr[4] = readb(f + 0x3FFB0 + 7);
-		nslu2_plat_eth[0].hwaddr[5] = readb(f + 0x3FFB0 + 6);
+			nslu2_plat_eth[0].hwaddr[i] = readb(f + 0x3FFB0 + (i^3));
 #endif
 		iounmap(f);
 	}
-	printk(KERN_INFO "NSLU2: Using MAC address %.2x:%.2x:%.2x:%.2x:%.2x:%.2x for port 0\n",
-	       nslu2_plat_eth[0].hwaddr[0], nslu2_plat_eth[0].hwaddr[1],
-	       nslu2_plat_eth[0].hwaddr[2], nslu2_plat_eth[0].hwaddr[3],
-	       nslu2_plat_eth[0].hwaddr[4], nslu2_plat_eth[0].hwaddr[5]);
+	printk(KERN_INFO "NSLU2: Using MAC address %s for port 0\n",
+		print_mac(mac_buf, nslu2_plat_eth[0].hwaddr));
 
 }
 
diff --git a/drivers/net/arm/ixp4xx_eth.c b/drivers/net/arm/ixp4xx_eth.c
index b654060..0ee490b 100644
--- a/drivers/net/arm/ixp4xx_eth.c
+++ b/drivers/net/arm/ixp4xx_eth.c
@@ -1257,5 +1257,6 @@ static void __exit eth_cleanup_module(void)
 MODULE_AUTHOR("Krzysztof Halasa");
 MODULE_DESCRIPTION("Intel IXP4xx Ethernet driver");
 MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:ixp4xx_eth");
 module_init(eth_init_module);
 module_exit(eth_cleanup_module);
diff --git a/include/asm-arm/arch-ixp4xx/platform.h b/include/asm-arm/arch-ixp4xx/platform.h
index 695b9c4..aee915f 100644
--- a/include/asm-arm/arch-ixp4xx/platform.h
+++ b/include/asm-arm/arch-ixp4xx/platform.h
@@ -77,7 +77,8 @@ extern unsigned long ixp4xx_exp_bus_size;
 
 /*
  * The IXP4xx chips do not have an I2C unit, so GPIO lines are just
- * used as platform_data to provide GPIO pin information to the ixp42x
+ * used to 
+ * Used as platform_data to provide GPIO pin information to the ixp42x
  * I2C driver.
  */
 struct ixp4xx_i2c_pins {
@@ -85,6 +86,22 @@ struct ixp4xx_i2c_pins {
 	unsigned long scl_pin;
 };
 
+/*
+ * This structure provide a means for the board setup code
+ * to give information to th pata_ixp4xx driver. It is
+ * passed as platform_data.
+ */
+struct ixp4xx_pata_data {
+	volatile u32	*cs0_cfg;
+	volatile u32	*cs1_cfg;
+	unsigned long	cs0_bits;
+	unsigned long	cs1_bits;
+	void __iomem	*cs0;
+	void __iomem	*cs1;
+};
+
+struct sys_timer;
+
 #define IXP4XX_ETH_NPEA		0x00
 #define IXP4XX_ETH_NPEB		0x10
 #define IXP4XX_ETH_NPEC		0x20
@@ -107,22 +124,6 @@ struct hss_plat_info {
 };
 
 /*
- * This structure provide a means for the board setup code
- * to give information to th pata_ixp4xx driver. It is
- * passed as platform_data.
- */
-struct ixp4xx_pata_data {
-	volatile u32	*cs0_cfg;
-	volatile u32	*cs1_cfg;
-	unsigned long	cs0_bits;
-	unsigned long	cs1_bits;
-	void __iomem	*cs0;
-	void __iomem	*cs1;
-};
-
-struct sys_timer;
-
-/*
  * Frequency of clock used for primary clocksource
  */
 extern unsigned long ixp4xx_timer_freq;
