commit 2ca7545f254a0a2f754bfbdaaba15aee85397cb7
Author: Alok Kataria <akataria@vmware.com>
Date:   Mon Jan 26 21:00:22 2009 +0100

    UBUNTU: x86: Add a synthetic TSC_RELIABLE feature bit.
    
    Bug: #319945
    
        Impact: Changes timebase calibration on Vmware.
    
        Use the synthetic TSC_RELIABLE bit to workaround virtualization anomalies.
    
        Virtual TSCs can be kept nearly in sync, but because the virtual TSC
        offset is set by software, it's not perfect.  So, the TSC
        synchronization test can fail. Even then the TSC can be used as a
        clocksource since the VMware platform exports a reliable TSC to the
        guest for timekeeping purposes. Use this bit to check if we need to
        skip the TSC sync checks.
    
        Along with this also set the CONSTANT_TSC bit when on VMware, since we
        still want to use TSC as clocksource on VM running over hardware which
        has unsynchronized TSC's (opteron's), since the hypervisor will take
        care of providing consistent TSC to the guest.
    
        Signed-off-by: Alok N Kataria <akataria@vmware.com>
        Signed-off-by: Dan Hecht <dhecht@vmware.com>
        Signed-off-by: H. Peter Anvin <hpa@zytor.com>
        Acked-by: Tim Gardner <tim.gardner@canonical.com>
        Acked-by: Stefan Bader <stefan.bader@canonical.com>

Adjusted to apply to Debian's 2.6.26 by dann frazier <dannf@debian.org>
and Ben Hutchings <ben@decadent.org.uk>

diff -urpN a/arch/x86/kernel/cpu/hypervisor.c b/arch/x86/kernel/cpu/hypervisor.c
--- a/arch/x86/kernel/cpu/hypervisor.c	2009-07-19 16:58:14.000000000 -0600
+++ b/arch/x86/kernel/cpu/hypervisor.c	2009-07-19 17:10:14.000000000 -0600
@@ -44,7 +44,17 @@ unsigned long get_hypervisor_tsc_freq(vo
 	return 0;
 }
 
+static inline void __cpuinit
+hypervisor_set_feature_bits(struct cpuinfo_x86 *c)
+{
+	if (x86_hyper_vendor == X86_HYPER_VENDOR_VMWARE) {
+		vmware_set_feature_bits(c);
+		return;
+	}
+}
+
 void __cpuinit init_hypervisor(struct cpuinfo_x86 *c)
 {
 	detect_hypervisor_vendor(c);
+	hypervisor_set_feature_bits(c);
 }
diff -urpN a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
--- a/arch/x86/kernel/cpu/vmware.c	2009-07-19 16:58:14.000000000 -0600
+++ b/arch/x86/kernel/cpu/vmware.c	2009-07-19 17:09:10.000000000 -0600
@@ -94,3 +94,21 @@ unsigned long vmware_get_tsc_khz(void)
 	BUG_ON(!vmware_platform());
 	return __vmware_get_tsc_khz();
 }
+
+/*
+ * VMware hypervisor takes care of exporting a reliable TSC to the guest.
+ * Still, due to timing difference when running on virtual cpus, the TSC can
+ * be marked as unstable in some cases. For example, the TSC sync check at
+ * bootup can fail due to a marginal offset between vcpus' TSCs (though the
+ * TSCs do not drift from each other).  Also, the ACPI PM timer clocksource
+ * is not suitable as a watchdog when running on a hypervisor because the
+ * kernel may miss a wrap of the counter if the vcpu is descheduled for a
+ * long time. To skip these checks at runtime we set these capability bits,
+ * so that the kernel could just trust the hypervisor with providing a
+ * reliable virtual TSC that is suitable for timekeeping.
+ */
+void __cpuinit vmware_set_feature_bits(struct cpuinfo_x86 *c)
+{
+	set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
+	set_cpu_cap(c, X86_FEATURE_TSC_RELIABLE);
+}
diff -urpN a/arch/x86/kernel/tsc_sync.c b/arch/x86/kernel/tsc_sync.c
--- a/arch/x86/kernel/tsc_sync.c	2008-07-13 15:51:29.000000000 -0600
+++ b/arch/x86/kernel/tsc_sync.c	2009-07-19 17:09:10.000000000 -0600
@@ -110,6 +110,12 @@ void __cpuinit check_tsc_sync_source(int
 	if (unsynchronized_tsc())
 		return;
 
+	if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE)) {
+		printk(KERN_INFO
+		       "Skipping synchronization checks as TSC is reliable.\n");
+		return;
+	}
+
 	printk(KERN_INFO "checking TSC synchronization [CPU#%d -> CPU#%d]:",
 			  smp_processor_id(), cpu);
 
@@ -163,7 +169,7 @@ void __cpuinit check_tsc_sync_target(voi
 {
 	int cpus = 2;
 
-	if (unsynchronized_tsc())
+	if (unsynchronized_tsc() || boot_cpu_has(X86_FEATURE_TSC_RELIABLE))
 		return;
 
 	/*
diff -urpN a/include/asm-x86/vmware.h b/include/asm-x86/vmware.h
--- a/include/asm-x86/vmware.h	2009-07-19 16:58:52.000000000 -0600
+++ b/include/asm-x86/vmware.h	2009-07-19 17:09:10.000000000 -0600
@@ -22,5 +22,6 @@
 
 extern unsigned long vmware_get_tsc_khz(void);
 extern int vmware_platform(void);
+extern void vmware_set_feature_bits(struct cpuinfo_x86 *c);
 
 #endif
