commit ccbe495caa5e604b04d5a31d7459a6f6a76a756c
Author: Roland McGrath <roland@redhat.com>
Date:   Fri Feb 27 19:03:24 2009 -0800

    x86-64: syscall-audit: fix 32/64 syscall hole
    
    On x86-64, a 32-bit process (TIF_IA32) can switch to 64-bit mode with
    ljmp, and then use the "syscall" instruction to make a 64-bit system
    call.  A 64-bit process make a 32-bit system call with int $0x80.
    
    In both these cases, audit_syscall_entry() will use the wrong system
    call number table and the wrong system call argument registers.  This
    could be used to circumvent a syscall audit configuration that filters
    based on the syscall numbers or argument details.
    
    Signed-off-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

Backported to Debian's 2.6.26 by dann frazier <dannf@debian.org>
Based on Eugene Teo's backport for RHEL5

diff -urpN linux-source-2.6.26.orig/arch/x86/kernel/ptrace.c linux-source-2.6.26/arch/x86/kernel/ptrace.c
--- linux-source-2.6.26.orig/arch/x86/kernel/ptrace.c	2009-03-25 17:20:38.000000000 -0600
+++ linux-source-2.6.26/arch/x86/kernel/ptrace.c	2009-04-04 11:09:01.000000000 -0600
@@ -1491,7 +1491,7 @@ asmlinkage void syscall_trace_enter(stru
 		syscall_trace(regs);
 
 	if (unlikely(current->audit_context)) {
-		if (test_thread_flag(TIF_IA32)) {
+		if (is_compat_task()) {
 			audit_syscall_entry(AUDIT_ARCH_I386,
 					    regs->orig_ax,
 					    regs->bx, regs->cx,
