commit 26398c096c180d5f02b0f379c12994cc8c639157
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Fri Dec 17 15:36:34 2010 -0500

    fix medium error problems with some arrays which can cause data corruption
    
    commit a8733c7baf457b071528e385a0b7d4aaec79287c upstream.
    
    Our current handling of medium error assumes that data is returned up
    to the bad sector.  This assumption holds good for all disk devices,
    all DIF arrays and most ordinary arrays.  However, an LSI array engine
    was recently discovered which reports a medium error without returning
    any data.  This means that when we report good data up to the medium
    error, we've reported junk originally in the buffer as good.  Worse,
    if the read consists of requested data plus a readahead, and the error
    occurs in readahead, we'll just strip off the readahead and report
    junk up to userspace as good data with no error.
    
    The fix for this is to have the error position computation take into
    account the amount of data returned by the driver using the scsi
    residual data.  Unfortunately, not every driver fills in this data,
    but for those who don't, it's set to zero, which means we'll think a
    full set of data was transferred and the behaviour will be identical
    to the prior behaviour of the code (believe the buffer up to the error
    sector).  All modern drivers seem to set the residual, so that should
    fix up the LSI failure/corruption case.
    
    Reported-by: Douglas Gilbert <dgilbert@interlog.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    [dannf: backported to Debian's 2.6.26]

diff -urpN linux-source-2.6.26.orig/drivers/scsi/sd.c linux-source-2.6.26/drivers/scsi/sd.c
--- linux-source-2.6.26.orig/drivers/scsi/sd.c	2008-07-13 23:51:29.000000000 +0200
+++ linux-source-2.6.26/drivers/scsi/sd.c	2011-05-10 17:29:03.605180930 +0200
@@ -944,6 +944,12 @@ static int sd_done(struct scsi_cmnd *SCp
 	int sense_valid = 0;
 	int sense_deferred = 0;
 	int info_valid;
+	/*
+	 * resid is optional but mostly filled in.  When it's unused,
+	 * its value is zero, so we assume the whole buffer transferred
+	 */
+	unsigned int transferred = scsi_bufflen(scmd) - scsi_get_resid(scmd);
+	unsigned int good_bytes;
 
 	if (result) {
 		sense_valid = scsi_command_normalize_sense(SCpnt, &sshdr);
@@ -997,7 +1003,8 @@ static int sd_done(struct scsi_cmnd *SCp
 		/* This computation should always be done in terms of
 		 * the resolution of the device's medium.
 		 */
-		good_bytes = (bad_lba - start_lba)*SCpnt->device->sector_size;
+		good_bytes = min((bad_lba - start_lba) * 
+				 SCpnt->device->sector_size, transferred);
 		break;
 	case RECOVERED_ERROR:
 	case NO_SENSE:
