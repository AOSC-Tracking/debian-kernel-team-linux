commit 8c4cabbf2516c203b76eeef04d03b260aeb6a941
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Feb 10 15:01:22 2011 -0800

    ptrace: use safer wake up on ptrace_detach()
    
    commit 01e05e9a90b8f4c3997ae0537e87720eb475e532 upstream.
    
    The wake_up_process() call in ptrace_detach() is spurious and not
    interlocked with the tracee state.  IOW, the tracee could be running or
    sleeping in any place in the kernel by the time wake_up_process() is
    called.  This can lead to the tracee waking up unexpectedly which can be
    dangerous.
    
    The wake_up is spurious and should be removed but for now reduce its
    toxicity by only waking up if the tracee is in TRACED or STOPPED state.
    
    This bug can possibly be used as an attack vector.  I don't think it
    will take too much effort to come up with an attack which triggers oops
    somewhere.  Most sleeps are wrapped in condition test loops and should
    be safe but we have quite a number of places where sleep and wakeup
    conditions are expected to be interlocked.  Although the window of
    opportunity is tiny, ptrace can be used by non-privileged users and with
    some loading the window can definitely be extended and exploited.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Roland McGrath <roland@redhat.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 85c1983..e194cd1 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -213,7 +213,7 @@ static inline void __ptrace_detach(struct task_struct *child, unsigned int data)
 	__ptrace_unlink(child);
 	/* .. and wake it up. */
 	if (child->exit_state != EXIT_ZOMBIE)
-		wake_up_process(child);
+		wake_up_state(child, TASK_TRACED | TASK_STOPPED);
 }
 
 int ptrace_detach(struct task_struct *child, unsigned int data)
