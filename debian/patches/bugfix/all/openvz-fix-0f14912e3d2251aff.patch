commit 0f14912e3d2251aff04950b267bfcad6dd99c05b
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 16:19:27 2008 +0400

    Fix oops when changing net.ipv4.ip_default_ttl
    
    Port from mainstream commit adf044c8778de98dae29c5ce9973b7e43964674f
    
        net: Add missing extra2 parameter for ip_default_ttl sysctl
    
        Commit 76e6ebfb40a2455c18234dcb0f9df37533215461 ("netns: add namespace
        parameter to rt_cache_flush") acceses the extra2 parameter of the
        ip_default_ttl ctl_table, but it is never set to a meaningful
        value. When e84f84f276473dcc673f360e8ff3203148bdf0e2 ("netns: place
        rt_genid into struct net") is applied, we'll oops in
        rt_cache_invalidate(). Set extra2 to init_net, to avoid that.
    
    http://bugzilla.openvz.org/show_bug.cgi?id=953
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit e744de05b10aeff8289c5d287ed92cbb0438426d
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:14:54 2008 +0400

    CPT: Fixed checkpoint error due to skipped mm->exe_file dump
    
    Fixed checkpoint error:
    
          CPT ERR: ffff81001dcfa800,2 :file struct is referenced outside 2 3
          CPT ERR: </sbin/init>
    
    Since mainstream commit 925d1c401fa6cfd0df5d2e37da8981494ccdec07
    structure mm_struct has pointer exe_file to execute file. So count
    this file in the prep state.
    
    During restore all vmas with VM_EXECUTABLE flag are related to the same
    file. So set set_mm_exe_file() only once.
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit bf29be7ffa8e5439046cc5eb98a2ff1f7e446518
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:13:55 2008 +0400

    mm: fixed error compilation with set SLAB_DEBUG
    
    Signed-off-by:  Vitaliy Gusev <vgusev@openvz.org>
    
    c6e43d1e5782f34d002f9d77a4f9f624b101f422
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit 490d44bfcb0ffbd3439fc83f7fb188e80bb0b3a2
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:13:24 2008 +0400

    Revert mmap deposixizatio patch
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit e2db3840d4f827dd762fba7e0ee889329f75a93a
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:12:44 2008 +0400

    proc: Fix error during insmod
    
    Fix error during insmod any module that try to call proc_mkdir("fs/xxx, NULL);
    
       FATAL: Error inserting nfsd (/lib/modules/2.6.26-ovz/kernel/fs/nfsd/nfsd.ko):
       Cannot allocate memory
    
    This error occurs as local proc root doesn't have
    "fs" entry and therefore xlate_proc_name() returns
    error.
    
    Related to bug http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=494384
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    
     fs/proc/root.c |    2 ++
     1 files changed, 2 insertions(+), 0 deletions(-)
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit 15ce7ef10f52493f94f5438d22a60a60e6bffdb0
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:10:49 2008 +0400

    CPT: Fix memory corruption
    
    Structure thread_struct has xstate member that is pointer to
    union thread_xstate.
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit d588f384c7a326c049f27cf4d90b949a89c1fe94
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Mon Aug 18 15:10:15 2008 +0400

    Ð¡PT: Use sock_create instead sock_create_kern
    
    sock_create_kern() uses init_net as default net namespace. Therefore
    sockets and net devices are belonged to init_net, though must belong
    to current net namespace.
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>

commit 9416cb37ce059d4f4f43c610d70e60d66d609c82
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Mon Aug 18 14:49:17 2008 +0400

    tcp: fix kernel panic with listening_get_next
    
    # BUG: unable to handle kernel NULL pointer dereference at
    0000000000000038
    IP: [<ffffffff821ed01e>] listening_get_next+0x50/0x1b3
    PGD 11e4b9067 PUD 11d16c067 PMD 0
    Oops: 0000 [1] SMP
    last sysfs file: /sys/devices/system/cpu/cpu3/cache/index2/shared_cpu_map
    CPU 3
    Modules linked in: bridge ipv6 button battery ac loop dm_mod tg3 ext3
    jbd edd fan thermal processor thermal_sys hwmon sg sata_svw libata dock
    serverworks sd_mod scsi_mod ide_disk ide_core [last unloaded: freq_table]
    Pid: 3368, comm: slpd Not tainted 2.6.26-rc2-mm1-lxc4 #1
    RIP: 0010:[<ffffffff821ed01e>] [<ffffffff821ed01e>]
    listening_get_next+0x50/0x1b3
    RSP: 0018:ffff81011e1fbe18 EFLAGS: 00010246
    RAX: 0000000000000000 RBX: ffff8100be0ad3c0 RCX: ffff8100619f50c0
    RDX: ffffffff82475be0 RSI: ffff81011d9ae6c0 RDI: ffff8100be0ad508
    RBP: ffff81011f4f1240 R08: 00000000ffffffff R09: ffff8101185b6780
    R10: 000000000000002d R11: ffffffff820fdbfa R12: ffff8100be0ad3c8
    R13: ffff8100be0ad6a0 R14: ffff8100be0ad3c0 R15: ffffffff825b8ce0
    FS: 00007f6a0ebd16d0(0000) GS:ffff81011f424540(0000)
    knlGS:0000000000000000
    CS: 0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000038 CR3: 000000011dc20000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process slpd (pid: 3368, threadinfo ffff81011e1fa000, task
    ffff81011f4b8660)
    Stack: 00000000000002ee ffff81011f5a57c0 ffff81011f4f1240
    ffff81011e1fbe90
    0000000000001000 0000000000000000 00007fff16bf2590 ffffffff821ed9c8
    ffff81011f5a57c0 ffff81011d9ae6c0 000000000000041a ffffffff820b0abd
    Call Trace:
    [<ffffffff821ed9c8>] ? tcp_seq_next+0x34/0x7e
    [<ffffffff820b0abd>] ? seq_read+0x1aa/0x29d
    [<ffffffff820d21b4>] ? proc_reg_read+0x73/0x8e
    [<ffffffff8209769c>] ? vfs_read+0xaa/0x152
    [<ffffffff82097a7d>] ? sys_read+0x45/0x6e
    [<ffffffff8200bd2b>] ? system_call_after_swapgs+0x7b/0x80
    
    Code: 31 a9 25 00 e9 b5 00 00 00 ff 45 20 83 7d 0c 01 75 79 4c 8b 75 10
    48 8b 0e eb 1d 48 8b 51 20 0f b7 45 08 39 02 75 0e 48 8b 41 28 <4c> 39
    78 38 0f 84 93 00 00 00 48 8b 09 48 85 c9 75 de 8b 55 1c
    RIP [<ffffffff821ed01e>] listening_get_next+0x50/0x1b3
    RSP <ffff81011e1fbe18>
    CR2: 0000000000000038
    
    This kernel panic appears with CONFIG_NET_NS=y.
    
    How to reproduce ?
    
        On the buggy host (host A)
           * ip addr add 1.2.3.4/24 dev eth0
    
        On a remote host (host B)
           * ip addr add 1.2.3.5/24 dev eth0
           * iptables -A INPUT -p tcp -s 1.2.3.4 -j DROP
           * ssh 1.2.3.4
    
        On host A:
           * netstat -ta or cat /proc/net/tcp
    
    This bug happens when reading /proc/net/tcp[6] when there is a req_sock
    at the SYN_RECV state.
    
    When a SYN is received the minisock is created and the sk field is set to
    NULL. In the listening_get_next function, we try to look at the field
    req->sk->sk_net.
    
    When looking at how to fix this bug, I noticed that is useless to do
    the check for the minisock belonging to the namespace. A minisock belongs
    to a listen point and this one is per namespace, so when browsing the
    minisock they are always per namespace.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
diff --git a/arch/x86/kernel/i387.c b/arch/x86/kernel/i387.c
index 95e80e5..bbcaada 100644
--- a/arch/x86/kernel/i387.c
+++ b/arch/x86/kernel/i387.c
@@ -144,6 +144,7 @@ int init_fpu(struct task_struct *tsk)
 	set_stopped_child_used_math(tsk);
 	return 0;
 }
+EXPORT_SYMBOL(init_fpu);
 
 int fpregs_active(struct task_struct *target, const struct user_regset *regset)
 {
diff --git a/fs/proc/base.c b/fs/proc/base.c
index fb40acb..0e7207f 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1268,6 +1268,7 @@ void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)
 	mm->exe_file = new_exe_file;
 	mm->num_exe_file_vmas = 0;
 }
+EXPORT_SYMBOL(set_mm_exe_file);
 
 struct file *get_mm_exe_file(struct mm_struct *mm)
 {
diff --git a/fs/proc/root.c b/fs/proc/root.c
index e2390df..bc93788 100644
--- a/fs/proc/root.c
+++ b/fs/proc/root.c
@@ -138,6 +138,8 @@ void __init proc_root_init(void)
 	proc_mkdir("sysvipc", &glob_proc_root);
 #endif
 	proc_mkdir("fs", &glob_proc_root);
+	proc_mkdir("fs", NULL);	/* care about proc_mkdir("fs/xxx", NULL); */
+
 	proc_mkdir("driver", NULL);
 	proc_mkdir("fs/nfsd", &glob_proc_root); /* somewhere for the nfsd filesystem to be mounted */
 #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)
diff --git a/kernel/cpt/cpt_mm.c b/kernel/cpt/cpt_mm.c
index a3d8c8e..4e98a8e 100644
--- a/kernel/cpt/cpt_mm.c
+++ b/kernel/cpt/cpt_mm.c
@@ -78,6 +78,11 @@ static int collect_one_mm(struct mm_struct *mm, cpt_context_t * ctx)
 				return -ENOMEM;
 		}
 	}
+
+	if (mm->exe_file &&
+	    cpt_object_add(CPT_OBJ_FILE, mm->exe_file, ctx) == NULL)
+		return -ENOMEM;
+
 #ifdef CONFIG_BEANCOUNTERS
 	if (cpt_add_ubc(mm->mm_ub, ctx) == NULL)
 		return -ENOMEM;
diff --git a/kernel/cpt/cpt_net.c b/kernel/cpt/cpt_net.c
index 373db60..78919d8 100644
--- a/kernel/cpt/cpt_net.c
+++ b/kernel/cpt/cpt_net.c
@@ -337,7 +337,7 @@ static int cpt_dump_route(struct cpt_context * ctx)
 	mm_segment_t oldfs;
 	char *pg;
 
-	err = sock_create_kern(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, &sock);
+	err = sock_create(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, &sock);
 	if (err)
 		return err;
 
diff --git a/kernel/cpt/cpt_process.c b/kernel/cpt/cpt_process.c
index 4ceb351..0a1e109 100644
--- a/kernel/cpt/cpt_process.c
+++ b/kernel/cpt/cpt_process.c
@@ -471,6 +471,9 @@ static int dump_fpustate(struct task_struct *tsk, struct cpt_context *ctx)
 	unsigned long size;
 	int type;
 
+	if (!tsk->thread.xstate)
+		return 0;
+
 	cpt_open_object(NULL, ctx);
 
 	type = CPT_CONTENT_X86_FPUSTATE;
@@ -489,7 +492,7 @@ static int dump_fpustate(struct task_struct *tsk, struct cpt_context *ctx)
 	hdr.cpt_size = size;
 
 	ctx->write(&hdr, sizeof(hdr), ctx);
-	ctx->write(&tsk->thread.xstate, size, ctx);
+	ctx->write(tsk->thread.xstate, size, ctx);
 	ctx->align(ctx);
 	cpt_close_object(ctx);
 	return 0;
diff --git a/kernel/cpt/rst_mm.c b/kernel/cpt/rst_mm.c
index 380b382..377e2e8 100644
--- a/kernel/cpt/rst_mm.c
+++ b/kernel/cpt/rst_mm.c
@@ -481,6 +481,8 @@ static int copy_mm_pages(struct mm_struct *src, unsigned long start,
 	return 0;
 }
 
+#include <linux/proc_fs.h>
+
 static int do_rst_vma(struct cpt_vma_image *vmai, loff_t vmapos, loff_t mmpos, struct cpt_context *ctx)
 {
 	int err = 0;
@@ -518,6 +520,10 @@ static int do_rst_vma(struct cpt_vma_image *vmai, loff_t vmapos, loff_t mmpos, s
 	}
 
 	down_write(&mm->mmap_sem);
+
+	if ((make_flags(vmai) & VM_EXECUTABLE) && mm->exe_file != file)
+		set_mm_exe_file(mm, file);
+
 	addr = do_mmap_pgoff(file, vmai->cpt_start,
 			     vmai->cpt_end-vmai->cpt_start,
 			     prot, make_flags(vmai),
diff --git a/kernel/cpt/rst_net.c b/kernel/cpt/rst_net.c
index b246ddb..c6be61a 100644
--- a/kernel/cpt/rst_net.c
+++ b/kernel/cpt/rst_net.c
@@ -202,7 +202,7 @@ int rst_restore_route(struct cpt_context *ctx)
 	if (err < 0)
 		return err;
 
-	err = sock_create_kern(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, &sock);
+	err = sock_create(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE, &sock);
 	if (err)
 		return err;
 
diff --git a/kernel/cpt/rst_process.c b/kernel/cpt/rst_process.c
index 0f60a06..f3f383c 100644
--- a/kernel/cpt/rst_process.c
+++ b/kernel/cpt/rst_process.c
@@ -1192,6 +1192,10 @@ static void rst_apply_mxcsr_mask(struct task_struct *tsk)
 #endif
 }
 
+#ifdef CONFIG_X86
+#include <asm/i387.h>
+#endif
+
 int rst_restore_process(struct cpt_context *ctx)
 {
 	cpt_object_t *obj;
@@ -1365,7 +1369,9 @@ int rst_restore_process(struct cpt_context *ctx)
 			case CPT_OBJ_BITS:
 				if (b->cpt_content == CPT_CONTENT_X86_FPUSTATE &&
 				    cpu_has_fxsr) {
-					memcpy(&tsk->thread.xstate,
+					if (init_fpu(tsk))
+						return -ENOMEM;
+					memcpy(tsk->thread.xstate,
 					       (void*)b + b->cpt_hdrlen,
 					       sizeof(struct i387_fxsave_struct));
 					rst_apply_mxcsr_mask(tsk);
@@ -1375,7 +1381,9 @@ int rst_restore_process(struct cpt_context *ctx)
 #ifndef CONFIG_X86_64
 				else if (b->cpt_content == CPT_CONTENT_X86_FPUSTATE_OLD &&
 					 !cpu_has_fxsr) {		
-					memcpy(&tsk->thread.xstate,
+					if (init_fpu(tsk))
+						return -ENOMEM;
+					memcpy(tsk->thread.xstate,
 					       (void*)b + b->cpt_hdrlen,
 					       sizeof(struct i387_fsave_struct));
 					if (ti->cpt_used_math)
diff --git a/kernel/cpt/rst_socket.c b/kernel/cpt/rst_socket.c
index d90488e..4963f34 100644
--- a/kernel/cpt/rst_socket.c
+++ b/kernel/cpt/rst_socket.c
@@ -268,13 +268,13 @@ static int open_socket(cpt_object_t *obj, struct cpt_sock_image *si,
 	cpt_object_t *fobj;
 	cpt_object_t *pobj = NULL;
 
-	err = sock_create_kern(si->cpt_family, si->cpt_type, si->cpt_protocol,
+	err = sock_create(si->cpt_family, si->cpt_type, si->cpt_protocol,
 			       &sock);
 	if (err)
 		return err;
 
 	if (si->cpt_socketpair) {
-		err = sock_create_kern(si->cpt_family, si->cpt_type,
+		err = sock_create(si->cpt_family, si->cpt_type,
 				       si->cpt_protocol, &sock2);
 		if (err)
 			goto err_out;
@@ -436,10 +436,10 @@ static int open_listening_socket(loff_t pos, struct cpt_sock_image *si,
 	struct file *file;
 	cpt_object_t *obj, *fobj;
 
-	err = sock_create_kern(si->cpt_family, si->cpt_type, si->cpt_protocol,
+	err = sock_create(si->cpt_family, si->cpt_type, si->cpt_protocol,
 			       &sock);
 	if (err) {
-		eprintk_ctx("open_listening_socket: sock_create_kern: %d\n", err);
+		eprintk_ctx("open_listening_socket: sock_create: %d\n", err);
 		return err;
 	}
 
diff --git a/mm/mmap.c b/mm/mmap.c
index 89b2ef2..e0bd041 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -946,7 +946,7 @@ unsigned long do_mmap_pgoff(struct file * file, unsigned long addr,
 			prot |= PROT_EXEC;
 
 	if (!len)
-		return addr;
+		return -EINVAL;
 
 	if (!(flags & MAP_FIXED))
 		addr = round_hint_to_min(addr);
diff --git a/mm/slab.c b/mm/slab.c
index bf82112..5ab164e 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -160,7 +160,7 @@
 			 SLAB_STORE_USER | \
 			 SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | \
 			 SLAB_DESTROY_BY_RCU | SLAB_MEM_SPREAD | \
-			 SLAB_UBC | SLAB_NO_CHARGE)
+			 SLAB_UBC | SLAB_NO_CHARGE | \
 			 SLAB_DEBUG_OBJECTS)
 #else
 # define CREATE_MASK	(SLAB_HWCACHE_ALIGN | \
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index e69d5ee..2beefa3 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -237,6 +237,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= &ipv4_doint_and_flush,
 		.strategy	= &ipv4_doint_and_flush_strategy,
+		.extra2		= &init_net,
 	},
 	{
 		.ctl_name	= NET_IPV4_NO_PMTU_DISC,
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index ca6b5d3..ce9a9cb 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1974,8 +1974,7 @@ static void *listening_get_next(struct seq_file *seq, void *cur)
 		req = req->dl_next;
 		while (1) {
 			while (req) {
-				if (req->rsk_ops->family == st->family &&
-				    net_eq(sock_net(req->sk), net)) {
+				if (req->rsk_ops->family == st->family) {
 					cur = req;
 					goto out;
 				}
