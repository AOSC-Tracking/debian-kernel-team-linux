commit ef3481c525adee77cb5f338ff23644a4fb71c427
Author: dann frazier <dannf@hp.com>
Date:   Wed Aug 18 17:02:08 2010 -0600

    [ backport of 7c88db0cb589df980acfb2f73c3595a0653004ec to 2.7.27.3 by Joe
    Korty <joe.korty@ccur.com ]
    
    [ backported to Debian's 2.6.26 by dann frazier <dannf@debian.org> ]
    
    proc: fix vma display mismatch between /proc/pid/{maps,smaps}
    
    Commit 4752c369789250eafcd7813e11c8fb689235b0d2 aka
    "maps4: simplify interdependence of maps and smaps" broke /proc/pid/smaps,
    causing it to display some vmas twice and other vmas not at all.  For example:
    
        grep .- /proc/1/smaps >/tmp/smaps; diff /proc/1/maps /tmp/smaps
    
        1  25d24
        2  < 7fd7e23aa000-7fd7e23ac000 rw-p 7fd7e23aa000 00:00 0
        3  28a28
        4  > ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0  [vsyscall]
    
    The bug has something to do with setting m->version before all the
    seq_printf's have been performed.  show_map was doing this correctly,
    but show_smap was doing this in the middle of its seq_printf sequence.
    This patch arranges things so that the setting of m->version in show_smap
    is also done at the end of its seq_printf sequence.
    
    Testing: in addition to the above grep test, for each process I summed
    up the 'Rss' fields of /proc/pid/smaps and compared that to the 'VmRSS'
    field of /proc/pid/status.  All matched except for Xorg (which has a
    /dev/mem mapping which Rss accounts for but VmRSS does not).  This result
    gives us some confidence that neither /proc/pid/maps nor /proc/pid/smaps
    are any longer skipping or double-counting vmas.
    
    Signed-off-by: Joe Korty <joe.korty@ccur.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 2819fcb..91ecd40 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -199,11 +199,8 @@ static int do_maps_open(struct inode *inode, struct file *file,
 	return ret;
 }
 
-static int show_map(struct seq_file *m, void *v)
+static void show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 {
-	struct proc_maps_private *priv = m->private;
-	struct task_struct *task = priv->task;
-	struct vm_area_struct *vma = v;
 	struct mm_struct *mm = vma->vm_mm;
 	struct file *file = vma->vm_file;
 	int flags = vma->vm_flags;
@@ -211,9 +208,6 @@ static int show_map(struct seq_file *m, void *v)
 	dev_t dev = 0;
 	int len;
 
-	if (maps_protect && !ptrace_may_attach(task))
-		return -EACCES;
-
 	if (file) {
 		struct inode *inode = vma->vm_file->f_path.dentry->d_inode;
 		dev = inode->i_sb->s_dev;
@@ -258,6 +252,18 @@ static int show_map(struct seq_file *m, void *v)
 		}
 	}
 	seq_putc(m, '\n');
+}
+
+static int show_map(struct seq_file *m, void *v)
+{
+	struct vm_area_struct *vma = v;
+	struct proc_maps_private *priv = m->private;
+	struct task_struct *task = priv->task;
+
+	if (maps_protect && !ptrace_may_attach(task))
+		return -EACCES;
+
+	show_map_vma(m, vma);
 
 	if (m->count < m->size)  /* vma is copied successfully */
 		m->version = (vma != get_gate_vma(task))? vma->vm_start: 0;
@@ -368,23 +374,25 @@ static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 
 static int show_smap(struct seq_file *m, void *v)
 {
+	struct proc_maps_private *priv = m->private;
+	struct task_struct *task = priv->task;
 	struct vm_area_struct *vma = v;
 	struct mem_size_stats mss;
-	int ret;
 	struct mm_walk smaps_walk = {
 		.pmd_entry = smaps_pte_range,
 		.mm = vma->vm_mm,
 		.private = &mss,
 	};
 
+	if (maps_protect && !ptrace_may_attach(task))
+		return -EACCES;
+
 	memset(&mss, 0, sizeof mss);
 	mss.vma = vma;
 	if (vma->vm_mm && !is_vm_hugetlb_page(vma))
 		walk_page_range(vma->vm_start, vma->vm_end, &smaps_walk);
 
-	ret = show_map(m, v);
-	if (ret)
-		return ret;
+	show_map_vma(m, vma);
 
 	seq_printf(m,
 		   "Size:           %8lu kB\n"
@@ -406,7 +414,9 @@ static int show_smap(struct seq_file *m, void *v)
 		   mss.referenced >> 10,
 		   mss.swap >> 10);
 
-	return ret;
+	if (m->count < m->size)  /* vma is copied successfully */
+		m->version = (vma != get_gate_vma(task)) ? vma->vm_start : 0;
+	return 0;
 }
 
 static const struct seq_operations proc_pid_smaps_op = {
