--- linux-2.6.18-m68k/drivers/net/atari_ethernec.c.ms.org	2007-01-03 13:52:39.000000000 +0100
+++ linux-2.6.18-m68k/drivers/net/atari_ethernec.c	2007-01-03 14:22:58.000000000 +0100
@@ -216,6 +216,12 @@
 
 static int use_poll = 0;
 
+/*
+ * We use timer D for polling; allow the user to specify the timer period (0.1 ms)!
+ */ 
+
+static int period = 0;
+
 /* This is used by cleanup, to prevent the module from being unloaded while
  * intrpt_routine is still in the task queue
  */
@@ -223,11 +229,13 @@
 
 static struct work_struct tqueue;
 
+#if defined (ETHERNEC_USE_POLL)
 static struct {
 	struct work_struct poll_queue;
 	struct timer_list poll_timer;
 	struct net_device *dev;
 } poll_ops;
+#endif
 
 static struct net_device *poll_dev = NULL;
 
@@ -511,7 +519,6 @@
 				printk(" (warning: no reset ack)");
 				break;
 			} else {
-				// MSch: ARAnyM exits here
 				printk(" not found (no reset ack).\n");
 				ret = -ENODEV;
 				goto err_out;
@@ -657,10 +664,19 @@
 		dev->irq = ETHERNEC_RTL_8019_IRQ;
 		/* timer routine set up in atari_ethernec_probe() */
 		if (dev->irq == IRQ_MFP_TIMD) {
+			/* period is in units of 0.1 ms, roughly */
+		        int timd = period * 4;
+		        if (timd == 0)
+		                timd = 192; 	/* default is 200 Hz */
+                        if (timd < 80) 
+                                timd = 80;	/* upper limit: 480 Hz */
+                        if (timd > 255)
+                                timd = 255;	/* lower limit: 150 Hz */
+                        printk("Timer D frequency: %d Hz\n", (int)(38400UL/(unsigned int)timd));
                         /* set Timer D data Register */
-                        mfp.tim_dt_d = 123;	/* 200 Hz */
-                        /* start timer D, div = 1:100 */
-                        mfp.tim_ct_cd = (mfp.tim_ct_cd & 0xf0) | 0x6; 
+                        mfp.tim_dt_d = timd;
+                        /* start timer D, div = 1:64, master clock = 2.46 MHz */
+                        mfp.tim_ct_cd = (mfp.tim_ct_cd & 0xf0) | 0x5;
                 }
 		ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
                 if (ret) {
@@ -989,7 +1005,7 @@
 #ifdef MODULE
 #define MAX_NE_CARDS	4	/* Max number of NE cards per module */
 static struct net_device *dev_ne[MAX_NE_CARDS];
-static int io[MAX_NE_CARDS];
+static int io[MAX_NE_CARDS] = { 0x300, };
 static int irq[MAX_NE_CARDS];
 static int bad[MAX_NE_CARDS];	/* 0xbad = bad sig or no reset ack */
 
@@ -997,10 +1013,12 @@
 module_param_array(irq, int, NULL, 0);
 module_param_array(bad, int, NULL, 0);
 module_param(use_poll, int, 0);
+module_param(period, int, 0);
 MODULE_PARM_DESC(io, "I/O base address(es),required");
 MODULE_PARM_DESC(irq, "IRQ number(s)");
 MODULE_PARM_DESC(bad, "Accept card(s) with bad signatures");
-MODULE_PARM_DESC(use_poll, "Use timer interrupt to poll driver");
+MODULE_PARM_DESC(use_poll, "Force use of timer interrupt to poll driver");
+MODULE_PARM_DESC(period, "MFP timer D period (0.1 ms)");
 MODULE_DESCRIPTION("NE1000/NE2000 ISA/PnP Ethernet driver");
 MODULE_LICENSE("GPL");
 
