diff -urN linux-m68k/arch/m68k/Kconfig linux-schmitz/arch/m68k/Kconfig
--- linux-m68k/arch/m68k/Kconfig	2006-11-19 21:35:33.000000000 +0100
+++ linux-schmitz/arch/m68k/Kconfig	2006-11-19 21:37:26.000000000 +0100
@@ -132,6 +132,31 @@
 	  information about which PCI hardware does work under Linux and which
 	  doesn't.
 
+config ATARI_ROM_ISA
+	bool "Atari ROM port ISA adapter support"
+	depends on ATARI
+	help
+	  This option enables support for the ROM port ISA adapter used to 
+	  operate ISA cards on Atari. Only 8  bit cards are supported, and
+	  no interrupt lines are connected. 
+	  The only driver currently using this adapter is the EtherNEC
+	  driver for RTL8019AS based NE2000 compatible network cards.
+
+config ARANYM
+	bool "ARAnyM emulator support "
+	depends on ATARI
+	help
+	  This option enables support for the ARAnyM emulator support
+	  features. To use this kernel on ARAnyM, say Y here; otherwise say N.
+
+config NATFEAT
+	bool
+	depends on ARANYM
+	default y
+	help
+	  This option enables support for ARAnyM native features, such as 
+	  access to a disk image as /dev/hda. Useful with the ARANYM option.
+
 config MAC
 	bool "Macintosh support"
 	depends on !MMU_SUN3
diff -urN linux-m68k/arch/m68k/atari/Makefile linux-schmitz/arch/m68k/atari/Makefile
--- linux-m68k/arch/m68k/atari/Makefile	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/arch/m68k/atari/Makefile	2006-11-19 21:37:26.000000000 +0100
@@ -3,8 +3,12 @@
 #
 
 obj-y		:= config.o time.o debug.o ataints.o stdma.o \
-			atasound.o stram.o atari_ksyms.o
+			atakeyb.o atasound.o stram.o atari_ksyms.o
 
 ifeq ($(CONFIG_PCI),y)
 obj-$(CONFIG_HADES)	+= hades-pci.o
 endif
+
+ifeq ($(CONFIG_NATFEAT),y)
+obj-$(CONFIG_NATFEAT)	+= natfeat.o
+endif
diff -urN linux-m68k/arch/m68k/atari/config.c linux-schmitz/arch/m68k/atari/config.c
--- linux-m68k/arch/m68k/atari/config.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/arch/m68k/atari/config.c	2006-11-19 21:37:26.000000000 +0100
@@ -32,6 +32,10 @@
 #include <linux/ioport.h>
 #include <linux/vt_kern.h>
 
+#ifdef CONFIG_NATFEAT
+#include "natfeat.h"
+#endif
+
 #include <asm/bootinfo.h>
 #include <asm/setup.h>
 #include <asm/atarihw.h>
@@ -207,6 +211,12 @@
     }
 }
 
+void atari_poweroff(void)
+{
+#ifdef CONFIG_NATFEAT
+    nf_shutdown();
+#endif
+}
 
     /*
      *  Setup the Atari configuration info
@@ -218,6 +228,10 @@
 
     memset(&atari_hw_present, 0, sizeof(atari_hw_present));
 
+#ifdef CONFIG_NATFEAT
+    nf_init();
+#endif
+
     atari_debug_init();
 
     ioport_resource.end  = 0xFFFFFFFF;  /* Change size of I/O space from 64KB
@@ -229,6 +243,8 @@
     mach_get_hardware_list = atari_get_hardware_list;
     mach_gettimeoffset   = atari_gettimeoffset;
     mach_reset           = atari_reset;
+    mach_halt            = atari_poweroff;
+    mach_power_off       = atari_poweroff;
     mach_max_dma_address = 0xffffff;
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
     mach_beep          = atari_mksound;
@@ -614,6 +630,11 @@
 
 static void atari_get_model(char *model)
 {
+#ifdef CONFIG_NATFEAT
+    if (nf_name1(model, 80)) { // char model[80] defined in kernel/setup.c
+       return;
+    }
+#endif
     strcpy(model, "Atari ");
     switch (atari_mch_cookie >> 16) {
 	case ATARI_MCH_ST:
diff -urN linux-m68k/arch/m68k/atari/ethernet_nfapi.h linux-schmitz/arch/m68k/atari/ethernet_nfapi.h
--- linux-m68k/arch/m68k/atari/ethernet_nfapi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/arch/m68k/atari/ethernet_nfapi.h	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * ARAnyM ethernet driver - header file.
+ *
+ * Copyright (c) 2002-2004 Standa and Petr of ARAnyM dev team (see AUTHORS)
+ * 
+ * This file is part of the ARAnyM project which builds a new and powerful
+ * TOS/FreeMiNT compatible virtual machine running on almost any hardware.
+ *
+ * ARAnyM is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * ARAnyM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ARAnyM; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ARAETHER_NFAPI_H
+#define _ARAETHER_NFAPI_H
+
+/*
+   The code for the FreeMiNT driver was moved to the FreeMiNT CVS:
+   freemint/sys/sockets/xif/nfeth.
+
+   If you edit this file then you would need to synchronize it with the
+   driver in the freemint CVS (nfeth_nfapi.h).
+
+   if you change anything in the enum {} below you have to increase 
+   this ARAETHER_NFAPI_VERSION!
+*/
+#define ARAETHER_NFAPI_VERSION	0x00000005
+
+enum {
+	GET_VERSION = 0,	/* no parameters, return NFAPI_VERSION in d0 */
+	XIF_INTLEVEL,		/* no parameters, return Interrupt Level in d0 */
+	XIF_IRQ,			/* acknowledge interrupt from host */
+	XIF_START,			/* (ethX), called on 'ifup', start receiver thread */
+	XIF_STOP,			/* (ethX), called on 'ifdown', stop the thread */
+	XIF_READLENGTH,		/* (ethX), return size of network data block to read */
+	XIF_READBLOCK,		/* (ethX, buffer, size), read block of network data */
+	XIF_WRITEBLOCK,		/* (ethX, buffer, size), write block of network data */
+	XIF_GET_MAC,		/* (ethX, buffer, size), return MAC HW addr in buffer */
+	XIF_GET_IPHOST,		/* (ethX, buffer, size), return IP address of host */
+	XIF_GET_IPATARI,	/* (ethX, buffer, size), return IP address of atari */
+	XIF_GET_NETMASK		/* (ethX, buffer, size), return IP netmask */
+};
+
+#define ETH(a)	(nfEtherID + a)
+
+#endif /* _ARAETHER_NFAPI_H */
diff -urN linux-m68k/arch/m68k/atari/natfeat.c linux-schmitz/arch/m68k/atari/natfeat.c
--- linux-m68k/arch/m68k/atari/natfeat.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/arch/m68k/atari/natfeat.c	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,231 @@
+/*
+ * natfeat.c - ARAnyM hardware support via Native Features (natfeats)
+ *
+ * Copyright (c) 2005 Petr Stehlik of ARAnyM dev team
+ *
+ * This software may be used and distributed according to the terms of
+ * the GNU General Public License (GPL), incorporated herein by reference.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/string.h> // strncpy()
+#include <linux/kernel.h> // snprintf()
+#include <asm/io.h> // virt_to_phys()
+
+#include "natfeat.h"
+
+#ifdef CONFIG_ATARI_NFETH
+#include "natfeat_ethernet_nfapi.h"
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+static unsigned long nf_get_id_instr = 0x73004e75UL;
+static unsigned long nf_call_instr = 0x73014e75UL;
+
+static struct nf_ops _nf_ops = { &nf_get_id_instr, &nf_call_instr }; 
+static struct nf_ops *nf_ops = NULL; 
+
+#define NF_GETID(a)		nf_ops->get_id(virt_to_phys(a))
+
+int detect_native_features(void)
+{
+    int		ret;
+    long	save_sp, save_vbr;
+    static long tmp_vectors[5];
+    static char *nf_version = "NF_VERSION";
+	
+    __asm__ __volatile__
+	(	"movec	%/vbr,%2\n\t"	/* save vbr value            */
+		"movel	#Liierr,%3@(0x10)\n\t" /* set Illegal Insn vec */
+ 		"movec	%3,%/vbr\n\t"	/* set up temporary vectors  */
+		"movel	%/sp,%1\n\t"	/* save sp                   */
+		"moveq	#0,%0\n\t"		/* assume no NatFeats        */
+		"clrl	%/d0\n\t"		/* clear ID value register   */
+		"movel	%4,%/sp@\n\t"
+		"subql	#4,%/sp\n\t"
+		"dc	0x7300\n\t"			/* call NatFeat GetID        */
+		"tstl	%/d0\n\t"		/* check ID value register   */
+		"sne	%0\n\t"			/* if non-zero NatFeats work */
+		"Liierr:\n\t"
+		"movel	%1,%/sp\n\t"	/* restore sp                */
+		"movec	%2,%/vbr"		/* restore vbr               */
+		: "=&d" (ret), "=&r" (save_sp), "=&r" (save_vbr)
+		: "a" (tmp_vectors), "a" (virt_to_phys(nf_version))
+		: "d0"					/* reg d0 used by NatFeats   */
+        );
+
+    return( ret );
+}
+
+struct nf_ops * nf_init(void)
+{
+	if (detect_native_features()) {
+		nf_ops = &_nf_ops;
+		nf_debug("NatFeats found\n");
+		return nf_ops;
+	}
+	
+	return NULL;
+}
+
+/****************/
+/* NF Basic Set */
+int nf_name1(char *buf, int bufsize)
+{
+	if (nf_ops) {
+		static long nfid_name = 0;
+		if (nfid_name == 0) {
+			nfid_name = NF_GETID("NF_NAME");
+		}
+
+		if (nfid_name) {
+			nf_ops->call(nfid_name+1, virt_to_phys(buf), bufsize); // TODO: lock buf to prevent swap out
+			return TRUE;
+		}
+	}
+        
+	return FALSE;
+}
+
+int nf_debug(const char *msg)
+{
+	if (nf_ops) {
+		static long nfid_stderr = 0;
+		if (nfid_stderr == 0) {
+			nfid_stderr = NF_GETID("NF_STDERR");
+		}
+		
+		if (nfid_stderr) {
+			nf_ops->call(nfid_stderr, virt_to_phys(msg)); // TODO: lock msg to prevent swap out
+			return TRUE;
+		}
+	}
+	
+	return FALSE;
+}
+
+int nf_shutdown(void)
+{
+	if (nf_ops) {
+		long shutdown_id = NF_GETID("NF_SHUTDOWN");
+		
+		if (shutdown_id) {
+			nf_ops->call(shutdown_id);
+			return TRUE; /* never returns actually */
+		}
+	}
+
+	return FALSE;
+}
+
+#ifdef CONFIG_ATARI_NFETH
+
+/****************************/
+/* NatFeat Ethernet support */
+static long nfEtherID = 0;
+
+static int is_nf_eth(void)
+{
+	if (nf_ops) {
+		if (nfEtherID == 0) {
+			nfEtherID = NF_GETID("ETHERNET");
+		}
+	}
+	return (nfEtherID != 0);
+}
+
+int nf_ethernet_check_version(char *errmsg, int errmsglen)
+{
+	if (is_nf_eth()) {
+		static unsigned long host_ver = 0;
+		if (host_ver == 0) {
+			host_ver = nf_ops->call(ETH(GET_VERSION));
+		}
+		if (host_ver == ARAETHER_NFAPI_VERSION) {
+			return TRUE;
+		}
+		else {
+			// API version mismatch
+			if (errmsg != NULL) {
+				snprintf(errmsg, errmsglen,
+					"NatFeat Ethernet API: expected %d, got %ld",
+					ARAETHER_NFAPI_VERSION, host_ver);
+			}
+			return FALSE;
+		}
+	}
+	if (errmsg != NULL) {
+		strncpy(errmsg, "NatFeat Ethernet support not found", errmsglen);
+	}
+	return FALSE;
+}
+
+int nf_ethernet_get_irq(void)
+{
+	return is_nf_eth() ? nf_ops->call(ETH(XIF_INTLEVEL)) : 0;
+}
+
+int nf_ethernet_get_hw_addr(int ethX, char *buffer, int bufsize)
+{
+	if (is_nf_eth()) {
+		return nf_ops->call(ETH(XIF_GET_MAC), (unsigned long)ethX, virt_to_phys(buffer), (unsigned long)bufsize); // TODO: lock buffer to prevent swap out
+	}
+	return FALSE;
+}
+
+int nf_ethernet_interrupt(int bit)
+{
+	if (is_nf_eth()) {
+		return nf_ops->call(ETH(XIF_IRQ), (unsigned long)bit);
+	}
+	return 0;
+}
+
+int nf_ethernet_read_packet_len(int ethX)
+{
+	if (is_nf_eth()) {
+		return nf_ops->call(ETH(XIF_READLENGTH), (unsigned long)ethX);
+	}
+	return 0;
+}
+
+void nf_ethernet_read_block(int ethX, char *buffer, int len)
+{
+	if (is_nf_eth()) {
+		nf_ops->call(ETH(XIF_READBLOCK), (unsigned long)ethX, virt_to_phys(buffer), (unsigned long)len); // TODO: lock buffer to prevent swap out
+	}
+}
+
+void nf_ethernet_write_block(int ethX, char *buffer, int len)
+{
+	if (is_nf_eth()) {
+		nf_ops->call(ETH(XIF_WRITEBLOCK), (unsigned long)ethX, virt_to_phys(buffer), (unsigned long)len); // TODO: lock buffer to prevent swap out
+	}
+}
+
+void nf_ethernet_xif_start(int ethX)
+{
+	if (is_nf_eth()) {
+		nf_ops->call(ETH(XIF_START), (unsigned long)ethX);
+	}
+}
+
+void nf_ethernet_xif_stop(int ethX)
+{
+	if (is_nf_eth()) {
+		nf_ops->call(ETH(XIF_STOP), (unsigned long)ethX);
+	}
+}
+#endif // CONFIG_ATARI_NFETH
+
+/*
+vim:ts=4:sw=4:
+*/
diff -urN linux-m68k/arch/m68k/atari/natfeat.h linux-schmitz/arch/m68k/atari/natfeat.h
--- linux-m68k/arch/m68k/atari/natfeat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/arch/m68k/atari/natfeat.h	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * ARAnyM hardware support via Native Features (natfeats)
+ *
+ * Copyright (c) 2005 Petr Stehlik of ARAnyM dev team
+ *
+ * This software may be used and distributed according to the terms of
+ * the GNU General Public License (GPL), incorporated herein by reference.
+ */
+
+#ifndef _natfeat_h
+#define _natfeat_h
+
+struct nf_ops
+{
+	long (*get_id)(const char *);
+	long (*call)(long id, ...);
+	long res[3];
+};
+
+struct nf_ops *nf_init(void);
+
+int nf_name(char *buf, int bufsize);
+int nf_debug(const char *msg);
+int nf_shutdown(void);
+
+int nf_ethernet_check_version(char *errmsg, int errmsglen);
+int nf_ethernet_get_irq(void);
+int nf_ethernet_get_hw_addr(int ethX, char *buffer, int bufsize);
+int nf_ethernet_interrupt(int bit);
+int nf_ethernet_read_packet_len(int ethX);
+void nf_ethernet_read_block(int ethX, char *buffer, int len);
+void nf_ethernet_write_block(int ethX, char *buffer, int len);
+void nf_ethernet_xif_start(int ethX);
+void nf_ethernet_xif_stop(int ethX);
+# endif /* _natfeat_h */
diff -urN linux-m68k/arch/m68k/atari/natfeat_ethernet_nfapi.h linux-schmitz/arch/m68k/atari/natfeat_ethernet_nfapi.h
--- linux-m68k/arch/m68k/atari/natfeat_ethernet_nfapi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/arch/m68k/atari/natfeat_ethernet_nfapi.h	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * ARAnyM ethernet driver - header file.
+ *
+ * Copyright (c) 2002-2004 Standa and Petr of ARAnyM dev team (see AUTHORS)
+ * 
+ * This file is part of the ARAnyM project which builds a new and powerful
+ * TOS/FreeMiNT compatible virtual machine running on almost any hardware.
+ *
+ * ARAnyM is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * ARAnyM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with ARAnyM; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ARAETHER_NFAPI_H
+#define _ARAETHER_NFAPI_H
+
+/*
+   The code for the FreeMiNT driver was moved to the FreeMiNT CVS:
+   freemint/sys/sockets/xif/nfeth.
+
+   If you edit this file then you would need to synchronize it with the
+   driver in the freemint CVS (nfeth_nfapi.h).
+
+   if you change anything in the enum {} below you have to increase 
+   this ARAETHER_NFAPI_VERSION!
+*/
+#define ARAETHER_NFAPI_VERSION	0x00000005
+
+enum {
+	GET_VERSION = 0,	/* no parameters, return NFAPI_VERSION in d0 */
+	XIF_INTLEVEL,		/* no parameters, return Interrupt Level in d0 */
+	XIF_IRQ,			/* acknowledge interrupt from host */
+	XIF_START,			/* (ethX), called on 'ifup', start receiver thread */
+	XIF_STOP,			/* (ethX), called on 'ifdown', stop the thread */
+	XIF_READLENGTH,		/* (ethX), return size of network data block to read */
+	XIF_READBLOCK,		/* (ethX, buffer, size), read block of network data */
+	XIF_WRITEBLOCK,		/* (ethX, buffer, size), write block of network data */
+	XIF_GET_MAC,		/* (ethX, buffer, size), return MAC HW addr in buffer */
+	XIF_GET_IPHOST,		/* (ethX, buffer, size), return IP address of host */
+	XIF_GET_IPATARI,	/* (ethX, buffer, size), return IP address of atari */
+	XIF_GET_NETMASK		/* (ethX, buffer, size), return IP netmask */
+};
+
+#define ETH(a)	(nfEtherID + a)
+
+#endif /* _ARAETHER_NFAPI_H */
diff -urN linux-m68k/drivers/net/Kconfig linux-schmitz/drivers/net/Kconfig
--- linux-m68k/drivers/net/Kconfig	2006-11-19 21:35:33.000000000 +0100
+++ linux-schmitz/drivers/net/Kconfig	2006-11-19 21:37:26.000000000 +0100
@@ -396,6 +396,22 @@
 	  ACSI port ("ACSI node"). The driver works (has to work...) with a
 	  polled I/O scheme, so it's rather slow :-(
 
+config ATARI_NFETH
+	tristate "Atari NatFeat Ethernet support"
+	depends on NET_ETHERNET && ATARI && NATFEAT
+	help
+	  Say Y to include support for the ARAnyM NatFeat network device
+	  which will emulate a regular ethernet device while presenting an
+	  ethertap device to the host system.
+
+config ATARI_ETHERNEC
+	tristate "Atari EtherNEC Ethernet support"
+	depends on NET_ETHERNET && ATARI && ATARI_ROM_ISA
+	help
+	  Say Y to include support for the EtherNEC network adapter for the
+	  ROM port. The driver works by polling instead of interrupts, so it
+	  is quite slow.
+
 config SUN3LANCE
 	tristate "Sun3/Sun3x on-board LANCE support"
 	depends on NET_ETHERNET && (SUN3 || SUN3X)
diff -urN linux-m68k/drivers/net/Makefile linux-schmitz/drivers/net/Makefile
--- linux-m68k/drivers/net/Makefile	2006-11-19 21:35:30.000000000 +0100
+++ linux-schmitz/drivers/net/Makefile	2006-11-19 21:37:26.000000000 +0100
@@ -182,6 +182,8 @@
 obj-$(CONFIG_ATARILANCE) += atarilance.o
 obj-$(CONFIG_ATARI_BIONET) += atari_bionet.o
 obj-$(CONFIG_ATARI_PAMSNET) += atari_pamsnet.o
+obj-$(CONFIG_ATARI_NFETH) += atari_nfeth.o
+obj-$(CONFIG_ATARI_ETHERNEC) += atari_ethernec.o 8390.o
 obj-$(CONFIG_A2065) += a2065.o
 obj-$(CONFIG_HYDRA) += hydra.o 8390.o
 obj-$(CONFIG_ARIADNE) += ariadne.o
diff -urN linux-m68k/drivers/net/Space.c linux-schmitz/drivers/net/Space.c
--- linux-m68k/drivers/net/Space.c	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/drivers/net/Space.c	2006-11-19 21:37:26.000000000 +0100
@@ -74,6 +74,8 @@
 extern struct net_device *seeq8005_probe(int unit);
 extern struct net_device *smc_init(int unit);
 extern struct net_device *atarilance_probe(int unit);
+extern struct net_device *atari_ethernec_probe(int unit);
+extern struct net_device *atari_nfeth_probe(struct net_device *);
 extern struct net_device *sun3lance_probe(int unit);
 extern struct net_device *sun3_82586_probe(int unit);
 extern struct net_device *apne_probe(int unit);
@@ -261,6 +263,12 @@
 #ifdef CONFIG_ATARILANCE	/* Lance-based Atari ethernet boards */
 	{atarilance_probe, 0},
 #endif
+#ifdef CONFIG_ATARI_NFETH	/* ARAnyM tun/tap device */
+	{atari_nfeth_probe, 0},
+#endif
+#ifdef CONFIG_ATARI_ETHERNEC	/* NE2000 based ROM port ethernet cards */
+	{atari_ethernec_probe, 0},
+#endif
 #ifdef CONFIG_SUN3LANCE         /* sun3 onboard Lance chip */
 	{sun3lance_probe, 0},
 #endif
diff -urN linux-m68k/drivers/net/atari_ethernec.c linux-schmitz/drivers/net/atari_ethernec.c
--- linux-m68k/drivers/net/atari_ethernec.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/drivers/net/atari_ethernec.c	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,1065 @@
+/* 
+ * atari_ethernec.c: Atari cartridge port ethernet adapter
+ * (C) 2006 Michael Schmitz
+ *
+ * Modified after: 
+ */
+
+/* ne.c: A general non-shared-memory NS8390 ethernet driver for linux. */
+/*
+    Written 1992-94 by Donald Becker.
+
+    Copyright 1993 United States Government as represented by the
+    Director, National Security Agency.
+
+    This software may be used and distributed according to the terms
+    of the GNU General Public License, incorporated herein by reference.
+
+    The author may be reached as becker@scyld.com, or C/O
+    Scyld Computing Corporation, 410 Severn Ave., Suite 210, Annapolis MD 21403
+
+    This driver should work with many programmed-I/O 8390-based ethernet
+    boards.  Currently it supports the NE1000, NE2000, many clones,
+    and some Cabletron products.
+
+    Changelog:
+
+    Paul Gortmaker	: use ENISR_RDC to monitor Tx PIO uploads, made
+			  sanity checks and bad clone support optional.
+    Paul Gortmaker	: new reset code, reset card after probe at boot.
+    Paul Gortmaker	: multiple card support for module users.
+    Paul Gortmaker	: Support for PCI ne2k clones, similar to lance.c
+    Paul Gortmaker	: Allow users with bad cards to avoid full probe.
+    Paul Gortmaker	: PCI probe changes, more PCI cards supported.
+    rjohnson@analogic.com : Changed init order so an interrupt will only
+    occur after memory is allocated for dev->priv. Deallocated memory
+    last in cleanup_modue()
+    Richard Guenther    : Added support for ISAPnP cards
+    Paul Gortmaker	: Discontinued PCI support - use ne2k-pci.c instead.
+    Hayato Fujiwara	: Add m32r support.
+
+*/
+
+/*
+ * From the driver distribution kit by Thomas Redelberger:
+ * 
+ * Hardware circuit description (see directory ETHERNEC for schematics)
+ *
+ * As there is no reset line on the CP, a resistor and a capacitor are
+ * used to reset the NE card on power up.
+ * 
+ * Reading from the NE card is done by a read cycle on the CP at address
+ * /ROM4 + 512*ISA address as the ISA address lines A0-A4 are connected
+ * to CP A9-A13. /ROM4 going low will start the ISA read cycle, enable
+ * the ISA bus buffers of the NE card and start decoding of the ISA IO
+ * address by the NE card. /ROM4 going high ends the cycle and the
+ * processor latches the data.
+ * 
+ * Because the CP is read only writing to the NE card must be done with
+ * the trick to read from addresses that stand for the data. Dummy reads
+ * at /ROM3 base address + data*2 + ISA address*512 effect this. You
+ * might wonder why everything appears to be shifted up one bit. There is
+ * no CP "A0" address line. There are the signals /UDS and /LDS instead
+ * typical for the 68000 family. The original design which generated an
+ * "A0" worked on an ST and an STE but did not on a Falcon.
+ * 
+ * The falling edge of /ROM3 enables the CP address lines A1-A8 onto the
+ * data bus and starts the ISA write cycle. The rising edge will end the
+ * ISA write cycle and the NE latches the data. The processor will also
+ * see and just read this same data but that is harmless.
+ * Elmar Hilgart reported that the bus buffer IC shall be an TTL F-type
+ * to keep up with the fast cycles on the Falcon.
+ *
+ * Base addresses:
+ * rom4            EQU     $00fa0000       ; ROM4 base address
+ * rom3            EQU     $00fb0000       ; ROM3 base address
+ *
+ */
+
+/* Routines for the NatSemi-based designs (NE[12]000). */
+
+static const char version1[] =
+"ne.c:v1.10 9/23/94 Donald Becker (becker@scyld.com)\n";
+static const char version2[] =
+"atari_ethernec.c 11/10/06 Michael Schmitz (schmitz@debian.org)\n";
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/isapnp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/jiffies.h>
+
+#include <asm/system.h>
+#include <asm/atarihw.h>
+#include <asm/atariints.h>
+#include <asm/io.h>
+
+#include "8390.h"
+
+#define DRV_NAME "ethernec"
+
+/* Some defines that people can play with if so inclined. */
+
+/* Do we support clones that don't adhere to 14,15 of the SAprom ? */
+#define SUPPORT_NE_BAD_CLONES
+
+/* Do we perform extra sanity checks on stuff ? */
+/* #define NE_SANITY_CHECK */
+
+/* Do we implement the read before write bugfix ? */
+/* #define NE_RW_BUGFIX */
+
+/* Do we have a non std. amount of memory? (in units of 256 byte pages) */
+/* #define PACKETBUF_MEMSIZE	0x40 */
+
+/* A zero-terminated list of I/O addresses to be probed at boot. */
+#ifndef MODULE
+static unsigned int netcard_portlist[] __initdata = {
+	0x300, 0x280, 0x320, 0x340, 0x360, 0x380, 0
+};
+#endif
+
+static struct isapnp_device_id isapnp_clone_list[] __initdata = {
+	{	ISAPNP_CARD_ID('A','X','E',0x2011),
+		ISAPNP_VENDOR('A','X','E'), ISAPNP_FUNCTION(0x2011),
+		(long) "NetGear EA201" },
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('E','D','I'), ISAPNP_FUNCTION(0x0216),
+		(long) "NN NE2000" },
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('P','N','P'), ISAPNP_FUNCTION(0x80d6),
+		(long) "Generic PNP" },
+	{ }	/* terminate list */
+};
+
+MODULE_DEVICE_TABLE(isapnp, isapnp_clone_list);
+
+#ifdef SUPPORT_NE_BAD_CLONES
+/* A list of bad clones that we none-the-less recognize. */
+static struct { const char *name8, *name16; unsigned char SAprefix[4];}
+bad_clone_list[] __initdata = {
+    {"DE100", "DE200", {0x00, 0xDE, 0x01,}},
+    {"DE120", "DE220", {0x00, 0x80, 0xc8,}},
+    {"DFI1000", "DFI2000", {'D', 'F', 'I',}}, /* Original, eh?  */
+    {"EtherNext UTP8", "EtherNext UTP16", {0x00, 0x00, 0x79}},
+    {"NE1000","NE2000-invalid", {0x00, 0x00, 0xd8}}, /* Ancient real NE1000. */
+    {"NN1000", "NN2000",  {0x08, 0x03, 0x08}}, /* Outlaw no-name clone. */
+    {"4-DIM8","4-DIM16", {0x00,0x00,0x4d,}},  /* Outlaw 4-Dimension cards. */
+    {"Con-Intl_8", "Con-Intl_16", {0x00, 0x00, 0x24}}, /* Connect Int'nl */
+    {"ET-100","ET-200", {0x00, 0x45, 0x54}}, /* YANG and YA clone */
+    {"COMPEX","COMPEX16",{0x00,0x80,0x48}}, /* Broken ISA Compex cards */
+    {"E-LAN100", "E-LAN200", {0x00, 0x00, 0x5d}}, /* Broken ne1000 clones */
+    {"PCM-4823", "PCM-4823", {0x00, 0xc0, 0x6c}}, /* Broken Advantech MoBo */
+    {"REALTEK", "RTL8019", {0x00, 0x00, 0xe8}}, /* no-name with Realtek chip */
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+    {"RBHMA4X00-RTL8019", "RBHMA4X00/RTL8019", {0x00, 0x60, 0x0a}},  /* Toshiba built-in */
+#endif
+    {"LCS-8834", "LCS-8836", {0x04, 0x04, 0x37}}, /* ShinyNet (SET) */
+    {NULL,}
+};
+#endif
+
+/* ---- No user-serviceable parts below ---- */
+
+#define NE_BASE	 (dev->base_addr)
+#define NE_CMD	 	0x00
+#define NE_DATAPORT	0x10	/* NatSemi-defined port window offset. */
+#define NE_RESET	0x1f	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT	0x20
+
+#define NE1SM_START_PG	0x20	/* First page of TX buffer */
+#define NE1SM_STOP_PG 	0x40	/* Last page +1 of RX ring */
+#define NESM_START_PG	0x40	/* First page of TX buffer */
+#define NESM_STOP_PG	0x80	/* Last page +1 of RX ring */
+
+#if defined(CONFIG_PLAT_MAPPI)
+#  define DCR_VAL 0x4b
+#elif defined(CONFIG_PLAT_OAKS32R)  || \
+   defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938) || \
+   defined(CONFIG_ATARI_ETHERNEC)
+#  define DCR_VAL 0x48		/* 8-bit mode */
+#else
+#  define DCR_VAL 0x49
+#endif
+
+#if defined(CONFIG_ATARI_ETHERNEC)
+#  define ETHERNEC_RTL_8019_BASE 0x300
+#  define ETHERNEC_RTL_8019_IRQ IRQ_MFP_TIMD
+#endif
+
+static int ne_probe1(struct net_device *dev, int ioaddr);
+static int ne_probe_isapnp(struct net_device *dev);
+
+static int ne_open(struct net_device *dev);
+static int ne_close(struct net_device *dev);
+
+static void ne_reset_8390(struct net_device *dev);
+static void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,
+			  int ring_page);
+static void ne_block_input(struct net_device *dev, int count,
+			  struct sk_buff *skb, int ring_offset);
+static void ne_block_output(struct net_device *dev, const int count,
+		const unsigned char *buf, const int start_page);
+
+
+/*
+ * The Atari ROM port has no interrupt line, so we poll the card instead.
+ */
+
+static int use_poll = 0;
+
+/* This is used by cleanup, to prevent the module from being unloaded while
+ * intrpt_routine is still in the task queue
+ */
+static wait_queue_head_t WaitQ;
+
+static struct work_struct tqueue;
+
+static struct {
+	struct work_struct poll_queue;
+	struct timer_list poll_timer;
+	struct net_device *dev;
+} poll_ops;
+
+static struct net_device *poll_dev = NULL;
+
+static void atari_ethernec_int(unsigned long dev_addr)
+{
+	struct net_device *dev  = poll_dev;
+
+        if(!dev) {
+	        /* If cleanup wants us to die */
+                if (waitqueue_active(&WaitQ)) 
+                  wake_up(&WaitQ);               /* Now cleanup_module can return */
+                else
+                  /* Put ourselves back in the task queue */
+                  schedule_delayed_work(&tqueue, 1);
+		return;
+        }
+
+	if (netif_running(dev)) {
+		ei_interrupt(dev->irq, dev, NULL);
+        }
+
+	/* If cleanup wants us to die */
+	if (waitqueue_active(&WaitQ)) 
+	wake_up(&WaitQ);               /* Now cleanup_module can return */
+	else
+	/* Put ourselves back in the task queue */
+	schedule_delayed_work(&tqueue, 0); /* reduced delay from 1 */
+}
+
+#if defined (ETHERNEC_USE_POLL)
+static void atari_ethernec_poll_handler(unsigned long dev_addr)
+{
+	struct net_device *dev  = poll_dev;
+
+        if(!dev || !dev->poll_controller)
+		return;
+
+	if (netif_running(dev)) 
+		dev->poll_controller(dev);
+
+	schedule_work(&poll_ops.poll_queue);
+	mod_timer(&poll_ops.poll_timer, jiffies + HZ/100);
+}
+#endif
+
+static void atari_ethernec_start_poll(struct net_device *dev)
+{
+	poll_dev = dev;
+
+	init_waitqueue_head(&WaitQ);
+
+	INIT_WORK(&tqueue, (void (*)(void *))atari_ethernec_int, dev);
+	schedule_delayed_work(&tqueue, 1);
+#if defined (ETHERNEC_USE_POLL)
+	if ((!poll_ops.poll_queue.func || poll_ops.poll_queue.func == ei_interrupt)) {
+		if (!poll_ops.poll_queue.func)
+			INIT_WORK(&poll_ops.poll_queue, ei_interrupt, dev);
+
+		init_timer(&poll_ops.poll_timer);
+		poll_ops.poll_timer.function = atari_ethernec_poll_handler;
+		poll_ops.poll_timer.expires = jiffies + HZ / 5;
+		poll_ops.poll_timer.data = (unsigned long ) dev;
+		add_timer(&poll_ops.poll_timer);
+	}
+#endif
+}
+
+static void atari_ethernec_stop_poll(struct net_device *dev)
+{
+	poll_dev = NULL;
+
+	if (dev) {
+	        sleep_on(&WaitQ);
+	}
+
+#if defined (ETHERNEC_USE_POLL)
+	if (poll_ops.poll_queue.func == ei_interrupt) {
+		del_timer_sync(&poll_ops.poll_timer);
+	}
+#endif
+}
+
+
+/*  Probe for various non-shared-memory ethercards.
+
+   NEx000-clone boards have a Station Address PROM (SAPROM) in the packet
+   buffer memory space.  NE2000 clones have 0x57,0x57 in bytes 0x0e,0x0f of
+   the SAPROM, while other supposed NE2000 clones must be detected by their
+   SA prefix.
+
+   Reading the SAPROM from a word-wide card with the 8390 set in byte-wide
+   mode results in doubled values, which can be detected and compensated for.
+
+   The probe is also responsible for initializing the card and filling
+   in the 'dev' and 'ei_status' structures.
+
+   We use the minimum memory size for some ethercard product lines, iff we can't
+   distinguish models.  You can increase the packet buffer size by setting
+   PACKETBUF_MEMSIZE.  Reported Cabletron packet buffer locations are:
+	E1010   starts at 0x100 and ends at 0x2000.
+	E1010-x starts at 0x100 and ends at 0x8000. ("-x" means "more memory")
+	E2010	 starts at 0x100 and ends at 0x4000.
+	E2010-x starts at 0x100 and ends at 0xffff.  */
+
+static int __init do_ne_probe(struct net_device *dev)
+{
+	unsigned int base_addr = dev->base_addr;
+	int rv;
+#ifndef MODULE
+	int orig_irq = dev->irq;
+#endif
+
+	SET_MODULE_OWNER(dev);
+
+	/* First check any supplied i/o locations. User knows best. <cough> */
+	if (base_addr > 0x1ff) {	/* Check a single specified location. */
+		rv =ne_probe1(dev, base_addr);
+		if (!rv && use_poll) {
+			/* Seems we have a valid device here; set up polling routine */
+			poll_dev = dev;
+			atari_ethernec_start_poll(dev);
+		}
+		return rv;
+	} else if (base_addr != 0)	/* Don't probe at all. */
+		return -ENXIO;
+
+	/* Then look for any installed ISAPnP clones */
+	if (isapnp_present() && (ne_probe_isapnp(dev) == 0))
+		return 0;
+
+#ifndef MODULE
+	/* Last resort. The semi-risky ISA auto-probe. */
+	for (base_addr = 0; netcard_portlist[base_addr] != 0; base_addr++) {
+		int ioaddr = netcard_portlist[base_addr];
+		dev->irq = orig_irq;
+		rv = ne_probe1(dev, ioaddr);
+		if (rv == 0) {
+			if (use_poll) {
+				poll_dev = dev;
+				atari_ethernec_start_poll(dev);
+			}
+			return 0;
+		}
+	}
+#endif
+
+	return -ENODEV;
+}
+
+#ifndef MODULE
+struct net_device * __init atari_ethernec_probe(int unit)
+{
+	struct net_device *dev = alloc_ei_netdev();
+	int err;
+
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	sprintf(dev->name, "eth%d", unit);
+	netdev_boot_setup_check(dev);
+
+#ifdef CONFIG_ATARI_ETHERNEC
+	dev->base_addr = ETHERNEC_RTL_8019_BASE;
+	dev->irq = ETHERNEC_RTL_8019_IRQ;
+#endif
+	err = do_ne_probe(dev);
+	if (err)
+		goto out;
+
+	/* Seems we have a valid device here; set up polling routine */
+	return dev;
+out:
+	free_netdev(dev);
+	return ERR_PTR(err);
+}
+#endif
+
+static int __init ne_probe_isapnp(struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; isapnp_clone_list[i].vendor != 0; i++) {
+		struct pnp_dev *idev = NULL;
+
+		while ((idev = pnp_find_dev(NULL,
+					    isapnp_clone_list[i].vendor,
+					    isapnp_clone_list[i].function,
+					    idev))) {
+			/* Avoid already found cards from previous calls */
+			if (pnp_device_attach(idev) < 0)
+				continue;
+			if (pnp_activate_dev(idev) < 0) {
+			      	pnp_device_detach(idev);
+			      	continue;
+			}
+			/* if no io and irq, search for next */
+			if (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {
+				pnp_device_detach(idev);
+				continue;
+			}
+			/* found it */
+			dev->base_addr = pnp_port_start(idev, 0);
+			dev->irq = pnp_irq(idev, 0);
+			printk(KERN_INFO "atari_ethernec.c: ISAPnP reports %s at i/o %#lx, irq %d.\n",
+				(char *) isapnp_clone_list[i].driver_data,
+				dev->base_addr, dev->irq);
+			if (ne_probe1(dev, dev->base_addr) != 0) {	/* Shouldn't happen. */
+				printk(KERN_ERR "atari_ethernec.c: Probe of ISAPnP card at %#lx failed.\n", dev->base_addr);
+				pnp_device_detach(idev);
+				return -ENXIO;
+			}
+			ei_status.priv = (unsigned long)idev;
+			break;
+		}
+		if (!idev)
+			continue;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int __init ne_probe1(struct net_device *dev, int ioaddr)
+{
+	int i;
+	unsigned char SA_prom[32];
+	int wordlength = 2;
+	const char *name = NULL;
+	int start_page, stop_page;
+	int neX000, ctron, copam, bad_card;
+	int reg0, ret;
+	static unsigned version_printed;
+
+	if (!request_region(ioaddr, NE_IO_EXTENT, DRV_NAME))
+		return -EBUSY;
+
+	reg0 = inb_p(ioaddr);
+	if (reg0 == 0xFF) {
+		ret = -ENODEV;
+		goto err_out;
+	}
+
+	/* Do a preliminary verification that we have a 8390. */
+	{
+		int regd;
+		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+		regd = inb_p(ioaddr + 0x0d);
+		outb_p(0xff, ioaddr + 0x0d);
+		outb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);
+		inb_p(ioaddr + EN0_COUNTER0); /* Clear the counter by reading. */
+		if (inb_p(ioaddr + EN0_COUNTER0) != 0) {
+			outb_p(reg0, ioaddr);
+			outb_p(regd, ioaddr + 0x0d);	/* Restore the old values. */
+			ret = -ENODEV;
+			goto err_out;
+		}
+	}
+
+	if (ei_debug  &&  version_printed++ == 0)
+		printk(KERN_INFO "%s" KERN_INFO "%s", version1, version2);
+
+	/* A user with a poor card that fails to ack the reset, or that
+	   does not have a valid 0x57,0x57 signature can still use this
+	   without having to recompile. Specifying an i/o address along
+	   with an otherwise unused dev->mem_end value of "0xBAD" will
+	   cause the driver to skip these parts of the probe. */
+
+	bad_card = ((dev->base_addr != 0) && (dev->mem_end == 0xbad));
+
+	/* Reset card. Who knows what dain-bramaged state it was left in. */
+
+	{
+		unsigned long reset_start_time = jiffies;
+
+		/* DON'T change these to inb_p/outb_p or reset will fail on clones. */
+		outb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);
+
+		while ((inb_p(ioaddr + EN0_ISR) & ENISR_RESET) == 0)
+		if (time_after(jiffies, reset_start_time + 2*HZ/100)) {
+			if (bad_card) {
+				printk(" (warning: no reset ack)");
+				break;
+			} else {
+				// MSch: ARAnyM exits here
+				printk(" not found (no reset ack).\n");
+				ret = -ENODEV;
+				goto err_out;
+			}
+		}
+
+		outb_p(0xff, ioaddr + EN0_ISR);		/* Ack all intr. */
+	}
+
+	/* Read the 16 bytes of station address PROM.
+	   We must first initialize registers, similar to NS8390_init(eifdev, 0).
+	   We can't reliably read the SAPROM address without this.
+	   (I learned the hard way!). */
+	{
+		struct {unsigned char value, offset; } program_seq[] =
+		{
+			{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD}, /* Select page 0*/
+			{0x48,	EN0_DCFG},	/* Set byte-wide (0x48) access. */
+			{0x00,	EN0_RCNTLO},	/* Clear the count regs. */
+			{0x00,	EN0_RCNTHI},
+			{0x00,	EN0_IMR},	/* Mask completion irq. */
+			{0xFF,	EN0_ISR},
+			{E8390_RXOFF, EN0_RXCR},	/* 0x20  Set to monitor */
+			{E8390_TXOFF, EN0_TXCR},	/* 0x02  and loopback mode. */
+			{32,	EN0_RCNTLO},
+			{0x00,	EN0_RCNTHI},
+			{0x00,	EN0_RSARLO},	/* DMA starting at 0x0000. */
+			{0x00,	EN0_RSARHI},
+			{E8390_RREAD+E8390_START, E8390_CMD},
+		};
+
+		for (i = 0; i < sizeof(program_seq)/sizeof(program_seq[0]); i++)
+			outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
+
+	}
+	for(i = 0; i < 32 /*sizeof(SA_prom)*/; i+=2) {
+		SA_prom[i] = inb(ioaddr + NE_DATAPORT);
+		SA_prom[i+1] = inb(ioaddr + NE_DATAPORT);
+		if (SA_prom[i] != SA_prom[i+1])
+			wordlength = 1;
+	}
+
+	if (wordlength == 2)
+	{
+		for (i = 0; i < 16; i++)
+			SA_prom[i] = SA_prom[i+i];
+		/* We must set the 8390 for word mode. */
+		outb_p(DCR_VAL, ioaddr + EN0_DCFG);
+		start_page = NESM_START_PG;
+
+		/*
+		 * Realtek RTL8019AS datasheet says that the PSTOP register
+		 * shouldn't exceed 0x60 in 8-bit mode.
+		 * This chip can be identified by reading the signature from
+		 * the  remote byte count registers (otherwise write-only)...
+		 */
+		if ((DCR_VAL & 0x01) == 0 &&		/* 8-bit mode */
+		    inb(ioaddr + EN0_RCNTLO) == 0x50 &&
+		    inb(ioaddr + EN0_RCNTHI) == 0x70)
+			stop_page = 0x60;
+		else
+			stop_page = NESM_STOP_PG;
+	} else {
+		start_page = NE1SM_START_PG;
+		stop_page  = NE1SM_STOP_PG;
+	}
+
+#if  defined(CONFIG_PLAT_MAPPI) || defined(CONFIG_PLAT_OAKS32R)
+	neX000 = ((SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57)
+		|| (SA_prom[14] == 0x42 && SA_prom[15] == 0x42));
+#else
+	neX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);
+#endif
+	ctron =  (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);
+	copam =  (SA_prom[14] == 0x49 && SA_prom[15] == 0x00);
+
+	/* Set up the rest of the parameters. */
+	if (neX000 || bad_card || copam) {
+		name = (wordlength == 2) ? "NE2000" : "NE1000";
+	}
+	else if (ctron)
+	{
+		name = (wordlength == 2) ? "Ctron-8" : "Ctron-16";
+		start_page = 0x01;
+		stop_page = (wordlength == 2) ? 0x40 : 0x20;
+	}
+	else
+	{
+#ifdef SUPPORT_NE_BAD_CLONES
+		/* Ack!  Well, there might be a *bad* NE*000 clone there.
+		   Check for total bogus addresses. */
+		for (i = 0; bad_clone_list[i].name8; i++)
+		{
+			if (SA_prom[0] == bad_clone_list[i].SAprefix[0] &&
+				SA_prom[1] == bad_clone_list[i].SAprefix[1] &&
+				SA_prom[2] == bad_clone_list[i].SAprefix[2])
+			{
+				if (wordlength == 2)
+				{
+					name = bad_clone_list[i].name16;
+				} else {
+					name = bad_clone_list[i].name8;
+				}
+				break;
+			}
+		}
+		if (bad_clone_list[i].name8 == NULL)
+		{
+			printk(" not found (invalid signature %2.2x %2.2x).\n",
+				SA_prom[14], SA_prom[15]);
+			ret = -ENXIO;
+			goto err_out;
+		}
+#else
+		printk(" not found.\n");
+		ret = -ENXIO;
+		goto err_out;
+#endif
+	}
+
+	if (dev->irq < 2)
+	{
+		unsigned long cookie = probe_irq_on();
+		outb_p(0x50, ioaddr + EN0_IMR);	/* Enable one interrupt. */
+		outb_p(0x00, ioaddr + EN0_RCNTLO);
+		outb_p(0x00, ioaddr + EN0_RCNTHI);
+		outb_p(E8390_RREAD+E8390_START, ioaddr); /* Trigger it... */
+		mdelay(10);		/* wait 10ms for interrupt to propagate */
+		outb_p(0x00, ioaddr + EN0_IMR); 		/* Mask it again. */
+		dev->irq = probe_irq_off(cookie);
+		if (ei_debug > 2)
+			printk(" autoirq is %d\n", dev->irq);
+	} else if (dev->irq == 2)
+		/* Fixup for users that don't know that IRQ 2 is really IRQ 9,
+		   or don't know which one to set. */
+		dev->irq = 9;
+
+	/*
+	 * use timer based polling!
+	 */
+	if (! dev->irq) {
+		printk(" failed to detect IRQ line. Assuming irq %d\n", ETHERNEC_RTL_8019_IRQ);
+		dev->irq = ETHERNEC_RTL_8019_IRQ;
+		/* timer routine set up in atari_ethernec_probe() */
+		if (dev->irq == IRQ_MFP_TIMD) {
+                        /* set Timer D data Register */
+                        mfp.tim_dt_d = 123;	/* 200 Hz */
+                        /* start timer D, div = 1:100 */
+                        mfp.tim_ct_cd = (mfp.tim_ct_cd & 0xf0) | 0x6; 
+                }
+		ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
+                if (ret) {
+		    printk (" unable to get IRQ %d (errno=%d), polling instead.\n", dev->irq, ret);
+                    use_poll = 1;
+                }
+	} else {
+
+		/* Snarf the interrupt now.  There's no point in waiting since we cannot
+		   share and the board will usually be enabled. */
+		ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
+		if (ret) {
+			printk (" unable to get IRQ %d (errno=%d).\n", dev->irq, ret);
+			goto err_out;
+		}
+	}
+	dev->base_addr = ioaddr;
+
+#ifdef CONFIG_PLAT_MAPPI
+	outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP,
+		ioaddr + E8390_CMD); /* 0x61 */
+	for (i = 0 ; i < ETHER_ADDR_LEN ; i++) {
+		dev->dev_addr[i] = SA_prom[i]
+			= inb_p(ioaddr + EN1_PHYS_SHIFT(i));
+		printk(" %2.2x", SA_prom[i]);
+	}
+#else
+	for(i = 0; i < ETHER_ADDR_LEN; i++) {
+		printk(" %2.2x", SA_prom[i]);
+		dev->dev_addr[i] = SA_prom[i];
+	}
+#endif
+
+	printk("\n%s: %s found at %#x, using IRQ %d.\n",
+		dev->name, name, ioaddr, dev->irq);
+
+	ei_status.name = name;
+	ei_status.tx_start_page = start_page;
+	ei_status.stop_page = stop_page;
+
+	/* Use 16-bit mode only if this wasn't overridden by DCR_VAL */
+	ei_status.word16 = (wordlength == 2 && (DCR_VAL & 0x01));
+
+	ei_status.rx_start_page = start_page + TX_PAGES;
+#ifdef PACKETBUF_MEMSIZE
+	 /* Allow the packet buffer size to be overridden by know-it-alls. */
+	ei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;
+#endif
+
+	ei_status.reset_8390 = &ne_reset_8390;
+	ei_status.block_input = &ne_block_input;
+	ei_status.block_output = &ne_block_output;
+	ei_status.get_8390_hdr = &ne_get_8390_hdr;
+	ei_status.priv = 0;
+	dev->open = &ne_open;
+	dev->stop = &ne_close;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = ei_poll;
+#endif
+	NS8390_init(dev, 0);
+
+	ret = register_netdev(dev);
+	if (ret)
+		goto out_irq;
+	return 0;
+
+out_irq:
+	free_irq(dev->irq, dev);
+err_out:
+	release_region(ioaddr, NE_IO_EXTENT);
+	return ret;
+}
+
+static int ne_open(struct net_device *dev)
+{
+	ei_open(dev);
+	return 0;
+}
+
+static int ne_close(struct net_device *dev)
+{
+	if (ei_debug > 1)
+		printk(KERN_DEBUG "%s: Shutting down ethercard.\n", dev->name);
+	ei_close(dev);
+	return 0;
+}
+
+/* Hard reset the card.  This used to pause for the same period that a
+   8390 reset command required, but that shouldn't be necessary. */
+
+static void ne_reset_8390(struct net_device *dev)
+{
+	unsigned long reset_start_time = jiffies;
+
+	if (ei_debug > 1)
+		printk(KERN_DEBUG "resetting the 8390 t=%ld...", jiffies);
+
+	/* DON'T change these to inb_p/outb_p or reset will fail on clones. */
+	outb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);
+
+	ei_status.txing = 0;
+	ei_status.dmaing = 0;
+
+	/* This check _should_not_ be necessary, omit eventually. */
+	while ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)
+		if (time_after(jiffies, reset_start_time + 2*HZ/100)) {
+			printk(KERN_WARNING "%s: ne_reset_8390() did not complete.\n", dev->name);
+			break;
+		}
+	outb_p(ENISR_RESET, NE_BASE + EN0_ISR);	/* Ack intr. */
+}
+
+/* Grab the 8390 specific header. Similar to the block_input routine, but
+   we don't need to be concerned with ring wrap as the header will be at
+   the start of a page, so we optimize accordingly. */
+
+static void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)
+{
+	int nic_base = dev->base_addr;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_get_8390_hdr "
+			"[DMAstat:%d][irqlock:%d].\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+
+	ei_status.dmaing |= 0x01;
+	outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);
+	outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);
+	outb_p(0, nic_base + EN0_RCNTHI);
+	outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
+	outb_p(ring_page, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+
+	if (ei_status.word16)
+		insw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);
+	else
+		insb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+
+	le16_to_cpus(&hdr->count);
+}
+
+/* Block input and output, similar to the Crynwr packet driver.  If you
+   are porting to a new ethercard, look at the packet driver source for hints.
+   The NEx000 doesn't share the on-board packet memory -- you have to put
+   the packet out through the "remote DMA" dataport using outb. */
+
+static void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)
+{
+#ifdef NE_SANITY_CHECK
+	int xfer_count = count;
+#endif
+	int nic_base = dev->base_addr;
+	char *buf = skb->data;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_block_input "
+			"[DMAstat:%d][irqlock:%d].\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);
+	outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+	outb_p(count >> 8, nic_base + EN0_RCNTHI);
+	outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
+	outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+	if (ei_status.word16)
+	{
+		insw(NE_BASE + NE_DATAPORT,buf,count>>1);
+		if (count & 0x01)
+		{
+			buf[count-1] = inb(NE_BASE + NE_DATAPORT);
+#ifdef NE_SANITY_CHECK
+			xfer_count++;
+#endif
+		}
+	} else {
+		insb(NE_BASE + NE_DATAPORT, buf, count);
+	}
+
+#ifdef NE_SANITY_CHECK
+	/* This was for the ALPHA version only, but enough people have
+	   been encountering problems so it is still here.  If you see
+	   this message you either 1) have a slightly incompatible clone
+	   or 2) have noise/speed problems with your bus. */
+
+	if (ei_debug > 1)
+	{
+		/* DMA termination address check... */
+		int addr, tries = 20;
+		do {
+			/* DON'T check for 'inb_p(EN0_ISR) & ENISR_RDC' here
+			   -- it's broken for Rx on some cards! */
+			int high = inb_p(nic_base + EN0_RSARHI);
+			int low = inb_p(nic_base + EN0_RSARLO);
+			addr = (high << 8) + low;
+			if (((ring_offset + xfer_count) & 0xff) == low)
+				break;
+		} while (--tries > 0);
+	 	if (tries <= 0)
+			printk(KERN_WARNING "%s: RX transfer address mismatch,"
+				"%#4.4x (expected) vs. %#4.4x (actual).\n",
+				dev->name, ring_offset + xfer_count, addr);
+	}
+#endif
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+}
+
+static void ne_block_output(struct net_device *dev, int count,
+		const unsigned char *buf, const int start_page)
+{
+	int nic_base = NE_BASE;
+	unsigned long dma_start;
+#ifdef NE_SANITY_CHECK
+	int retries = 0;
+#endif
+
+	/* Round the count up for word writes.  Do we need to do this?
+	   What effect will an odd byte count have on the 8390?
+	   I should check someday. */
+
+	if (ei_status.word16 && (count & 0x01))
+		count++;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_block_output."
+			"[DMAstat:%d][irqlock:%d]\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	/* We should already be in page 0, but to be safe... */
+	outb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);
+
+#ifdef NE_SANITY_CHECK
+retry:
+#endif
+
+#ifdef NE8390_RW_BUGFIX
+	/* Handle the read-before-write bug the same way as the
+	   Crynwr packet driver -- the NatSemi method doesn't work.
+	   Actually this doesn't always work either, but if you have
+	   problems with your NEx000 this is better than nothing! */
+
+	outb_p(0x42, nic_base + EN0_RCNTLO);
+	outb_p(0x00,   nic_base + EN0_RCNTHI);
+	outb_p(0x42, nic_base + EN0_RSARLO);
+	outb_p(0x00, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+	/* Make certain that the dummy read has occurred. */
+	udelay(6);
+#endif
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);
+
+	/* Now the normal output. */
+	outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+	outb_p(count >> 8,   nic_base + EN0_RCNTHI);
+	outb_p(0x00, nic_base + EN0_RSARLO);
+	outb_p(start_page, nic_base + EN0_RSARHI);
+
+	outb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);
+	if (ei_status.word16) {
+		outsw(NE_BASE + NE_DATAPORT, buf, count>>1);
+	} else {
+		outsb(NE_BASE + NE_DATAPORT, buf, count);
+	}
+
+	dma_start = jiffies;
+
+#ifdef NE_SANITY_CHECK
+	/* This was for the ALPHA version only, but enough people have
+	   been encountering problems so it is still here. */
+
+	if (ei_debug > 1)
+	{
+		/* DMA termination address check... */
+		int addr, tries = 20;
+		do {
+			int high = inb_p(nic_base + EN0_RSARHI);
+			int low = inb_p(nic_base + EN0_RSARLO);
+			addr = (high << 8) + low;
+			if ((start_page << 8) + count == addr)
+				break;
+		} while (--tries > 0);
+
+		if (tries <= 0)
+		{
+			printk(KERN_WARNING "%s: Tx packet transfer address mismatch,"
+				"%#4.4x (expected) vs. %#4.4x (actual).\n",
+				dev->name, (start_page << 8) + count, addr);
+			if (retries++ == 0)
+				goto retry;
+		}
+	}
+#endif
+
+	while ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)
+		if (time_after(jiffies, dma_start + 2*HZ/100)) {		/* 20ms */
+			printk(KERN_WARNING "%s: timeout waiting for Tx RDC.\n", dev->name);
+			ne_reset_8390(dev);
+			NS8390_init(dev,1);
+			break;
+		}
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+	return;
+}
+
+
+#ifdef MODULE
+#define MAX_NE_CARDS	4	/* Max number of NE cards per module */
+static struct net_device *dev_ne[MAX_NE_CARDS];
+static int io[MAX_NE_CARDS];
+static int irq[MAX_NE_CARDS];
+static int bad[MAX_NE_CARDS];	/* 0xbad = bad sig or no reset ack */
+
+module_param_array(io, int, NULL, 0);
+module_param_array(irq, int, NULL, 0);
+module_param_array(bad, int, NULL, 0);
+module_param(use_poll, int, 0);
+MODULE_PARM_DESC(io, "I/O base address(es),required");
+MODULE_PARM_DESC(irq, "IRQ number(s)");
+MODULE_PARM_DESC(bad, "Accept card(s) with bad signatures");
+MODULE_PARM_DESC(use_poll, "Use timer interrupt to poll driver");
+MODULE_DESCRIPTION("NE1000/NE2000 ISA/PnP Ethernet driver");
+MODULE_LICENSE("GPL");
+
+/* This is set up so that no ISA autoprobe takes place. We can't guarantee
+that the ne2k probe is the last 8390 based probe to take place (as it
+is at boot) and so the probe will get confused by any other 8390 cards.
+ISA device autoprobes on a running machine are not recommended anyway. */
+
+int __init init_module(void)
+{
+	int this_dev, found = 0;
+
+	for (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {
+		struct net_device *dev = alloc_ei_netdev();
+		if (!dev)
+			break;
+		dev->irq = irq[this_dev];
+		dev->mem_end = bad[this_dev];
+		dev->base_addr = io[this_dev];
+		if (do_ne_probe(dev) == 0) {
+			dev_ne[found++] = dev;
+			continue;
+		}
+		free_netdev(dev);
+		if (found)
+			break;
+		if (io[this_dev] != 0)
+			printk(KERN_WARNING "atari_ethernec.c: No NE*000 card found at i/o = %#x\n", io[this_dev]);
+		else
+			printk(KERN_NOTICE "atari_ethernec.c: You must supply \"io=0xNNN\" value(s) for ISA cards.\n");
+		return -ENXIO;
+	}
+	if (found)
+		return 0;
+	return -ENODEV;
+}
+
+static void cleanup_card(struct net_device *dev)
+{
+	struct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;
+	if (idev)
+		pnp_device_detach(idev);
+	free_irq(dev->irq, dev);
+	release_region(dev->base_addr, NE_IO_EXTENT);
+}
+
+void cleanup_module(void)
+{
+	int this_dev;
+
+	for (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {
+		struct net_device *dev = dev_ne[this_dev];
+		if (dev) {
+			if (use_poll)
+                        	atari_ethernec_stop_poll(dev);
+			unregister_netdev(dev);
+			cleanup_card(dev);
+			free_netdev(dev);
+		}
+	}
+}
+#endif /* MODULE */
diff -urN linux-m68k/drivers/net/atari_nfeth.c linux-schmitz/drivers/net/atari_nfeth.c
--- linux-m68k/drivers/net/atari_nfeth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-schmitz/drivers/net/atari_nfeth.c	2006-11-19 21:37:26.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ * atari_nfeth.c - ARAnyM ethernet card driver for GNU/Linux
+ *
+ * Copyright (c) 2005 Milan Jurik, Petr Stehlik of ARAnyM dev team
+ *
+ * Based on ARAnyM driver for FreeMiNT written by Standa Opichal
+ * 
+ * This software may be used and distributed according to the terms of
+ * the GNU General Public License (GPL), incorporated herein by reference.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/module.h>
+#include <asm/atariints.h>
+
+#include "../../arch/m68k/atari/natfeat.h"
+
+#define DRV_NAME        "atari_nfeth"
+#define DRV_VERSION     "0.3"
+#define DRV_RELDATE     "10/12/2005"
+
+/* These identify the driver base version and may not be removed. */
+static char version[] __devinitdata =
+KERN_INFO DRV_NAME ".c:v" DRV_VERSION " " DRV_RELDATE " S.Opichal, M.Jurik, P.Stehlik\n"
+KERN_INFO "  http://aranym.atari.org/\n";
+
+MODULE_AUTHOR("Milan Jurik");
+MODULE_DESCRIPTION("Atari NFeth driver");
+MODULE_LICENSE("GPL");
+/*
+MODULE_PARM(atari_nfeth_debug, "i");
+MODULE_PARM_DESC(atari_nfeth_debug, "atari_nfeth_debug level (1-2)");
+*/
+
+#undef DEBUG
+
+struct atari_nfeth_private {
+	int ethX;
+	struct net_device_stats	stats;
+	spinlock_t lock;
+};
+
+static inline int getEthX(struct net_device *dev)
+{
+	return ((struct atari_nfeth_private *)netdev_priv(dev))->ethX;
+}
+
+int atari_nfeth_open(struct net_device *dev);
+int atari_nfeth_stop(struct net_device *dev);
+irqreturn_t atari_nfeth_interrupt(int irq, void *dev_id, struct pt_regs *fp);
+int atari_nfeth_xmit(struct sk_buff *skb, struct net_device *dev);
+
+int atari_nfeth_open(struct net_device *dev)
+{
+	nf_ethernet_xif_start(getEthX(dev));
+
+	/* Set IRQ */
+	dev->irq = nf_ethernet_get_irq();
+	if (request_irq(dev->irq, atari_nfeth_interrupt, IRQ_TYPE_PRIO, dev->name, dev)) {
+		printk( DRV_NAME ": request for irq %d failed\n", dev->irq);
+		return( 0 );
+	}
+
+	/* Clean statistics */
+	memset(&(((struct atari_nfeth_private *)netdev_priv(dev))->stats), 0, sizeof(((struct atari_nfeth_private *)(dev->priv))->stats));
+
+	spin_lock_init(&(((struct atari_nfeth_private *)netdev_priv(dev))->lock));
+
+#ifdef DEBUG
+	printk( DRV_NAME ": open");
+#endif
+
+	/* Ready for data */
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+int atari_nfeth_stop(struct net_device *dev)
+{
+	/* No more data */
+	netif_stop_queue(dev);
+
+	/* Release IRQ */
+	free_irq(dev->irq, dev);
+
+	nf_ethernet_xif_stop(getEthX(dev));
+
+	return 0;
+}
+
+/*
+ * Read a packet out of the adapter and pass it to the upper layers
+ */
+static irqreturn_t inline recv_packet (struct net_device *dev)
+{
+	int handled = 0;
+	unsigned short pktlen;
+	struct sk_buff *skb;
+	struct atari_nfeth_private *anp = (struct atari_nfeth_private *)netdev_priv(dev);
+
+	if (dev == NULL) {
+		printk(DRV_NAME " recv_packet(): interrupt for unknown device.\n");
+		return IRQ_NONE;
+	}
+
+	/* read packet length (excluding 32 bit crc) */
+	pktlen = nf_ethernet_read_packet_len(getEthX(dev));
+
+#ifdef DEBUG
+	printk(DRV_NAME ": recv_packet: %i", pktlen);
+#endif
+
+	//if (pktlen < 32)
+	if (!pktlen)
+	{
+#ifdef DEBUG
+		printk(DRV_NAME ": recv_packet: pktlen == 0");
+#endif
+		anp->stats.rx_errors++;
+		return IRQ_RETVAL(handled);
+	}
+
+	skb = dev_alloc_skb(pktlen + 2);
+	if (skb == NULL)
+	{
+#ifdef DEBUG
+		printk(DRV_NAME ": recv_packet: out of mem (buf_alloc failed)");
+#endif
+		anp->stats.rx_dropped++;
+		return IRQ_RETVAL(handled);
+	}
+
+	skb->dev = dev;
+	skb_reserve( skb, 2 );		/* 16 Byte align  */
+	skb_put( skb, pktlen );	/* make room */
+	nf_ethernet_read_block(getEthX(dev), skb->data, pktlen);
+
+	skb->protocol = eth_type_trans(skb, dev);
+	netif_rx(skb);
+	dev->last_rx = jiffies;
+	anp->stats.rx_packets++;
+	anp->stats.rx_bytes += pktlen;
+
+	/* and enqueue packet */
+	handled = 1;
+	return IRQ_RETVAL(handled);
+}
+
+irqreturn_t atari_nfeth_interrupt(int irq, void *dev_id, struct pt_regs *fp)
+{
+	struct net_device *dev = dev_id;
+	struct atari_nfeth_private *anp = (struct atari_nfeth_private *)netdev_priv(dev);
+	int this_dev_irq_bit;
+	int irq_for_eth_bitmask;
+	if (dev == NULL) {
+#ifdef DEBUG
+		printk(DRV_NAME " atari_nfeth_interrupt(): interrupt for unknown device.\n");
+#endif
+		return IRQ_NONE;
+	}
+	spin_lock(&anp->lock);
+	irq_for_eth_bitmask = nf_ethernet_interrupt(0);
+	this_dev_irq_bit = 1 << (anp->ethX);
+	if (this_dev_irq_bit & irq_for_eth_bitmask) {
+		recv_packet(dev);
+		nf_ethernet_interrupt(this_dev_irq_bit);
+	}
+#ifdef DEBUG
+	else {
+		printk(DRV_NAME " atari_nfeth_interrupt(%d): not for me\n", anp->ethX);
+	}
+#endif
+	spin_unlock(&anp->lock);
+}
+
+int atari_nfeth_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data, shortpkt[ETH_ZLEN];
+	struct atari_nfeth_private *anp = netdev_priv(dev);
+
+	data = skb->data;
+	len = skb->len;
+	if (len < ETH_ZLEN) {
+		memset(shortpkt, 0, ETH_ZLEN);
+		memcpy(shortpkt, data, len);
+		data = shortpkt;
+		len = ETH_ZLEN;
+	}
+
+	dev->trans_start = jiffies;
+	
+#ifdef DEBUG
+	printk( DRV_NAME ": send %d bytes", len);
+#endif
+	nf_ethernet_write_block(getEthX(dev), data, len);
+
+	anp->stats.tx_packets++;
+	anp->stats.tx_bytes += len;
+
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static void atari_nfeth_tx_timeout(struct net_device *dev)
+{
+	struct atari_nfeth_private *anp = netdev_priv(dev);
+	anp->stats.tx_errors++;
+	netif_wake_queue(dev);
+}
+
+static struct net_device_stats *atari_nfeth_get_stats(struct net_device *dev)
+{
+	struct atari_nfeth_private *anp = netdev_priv(dev);
+	return &(anp->stats);
+}
+
+// probe1() - HW detection
+// probe() - set module owner, found == 1, probe1()
+// init() - probe()
+
+static int __init atari_nfeth_probe1(struct net_device *dev, int ethX)
+{
+	static int did_version = 0;
+	static int did_notinstall = 0;
+	char errmsg[60];
+
+	if ( ! nf_ethernet_check_version(errmsg, sizeof(errmsg)-1) ) {
+		if (did_notinstall++ == 0)
+			printk (DRV_NAME " not installed - %s\n", errmsg);
+                return -ENODEV;
+        }
+
+	/* Get MAC address */
+	if (! nf_ethernet_get_hw_addr(ethX, (unsigned char *)&(dev->dev_addr), ETH_ALEN)) {
+#ifdef DEBUG
+		printk(DRV_NAME " eth%d not installed - not defined\n", ethX);
+#endif
+		return -ENODEV;
+	}
+
+	ether_setup(dev);
+
+	dev->open = &atari_nfeth_open;
+	dev->stop = &atari_nfeth_stop;
+	dev->hard_start_xmit = &atari_nfeth_xmit;
+	dev->tx_timeout = &atari_nfeth_tx_timeout;
+	dev->get_stats = &atari_nfeth_get_stats;
+	dev->flags |= NETIF_F_NO_CSUM;
+
+	//if ((dev->priv = kmalloc(sizeof(struct atari_nfeth_private), GFP_KERNEL)) == NULL)
+	//	return -ENOMEM;
+	((struct atari_nfeth_private *)(dev->priv))->ethX = ethX; /* index of NF NIC */
+
+	if (did_version++ == 0)
+		printk(version);
+
+	return 0;
+}
+
+struct net_device * __init atari_nfeth_probe(int unit)
+{
+        int err;
+	static int found = 0;
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(struct atari_nfeth_private));
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+	if (unit >= 0) {
+		sprintf(dev->name, "eth%d", unit);
+		netdev_boot_setup_check(dev);
+	}
+	SET_MODULE_OWNER(dev);
+
+	if (!atari_nfeth_probe1(dev, found++)) {
+		err = register_netdev(dev);
+		if (err == -EIO)  {
+			printk(DRV_NAME ": NatFeat Ethernet not found. Module not loaded.\n");
+		}
+		if (!err)
+			return dev;
+	}
+
+	return ERR_PTR(-ENODEV);
+}
+
+#ifdef MODULE
+static struct net_device * atari_nfeth_dev;
+
+int atari_nfeth_init(void)
+{
+	// int err;
+
+	if (IS_ERR(atari_nfeth_dev = atari_nfeth_probe(0))) {
+		return PTR_ERR((atarilance_dev);
+	}
+
+	// ? atari_nfeth_dev.init = atari_nfeth_probe;
+#if 0
+	if ((err = register_netdev(&atari_nfeth_dev))) {
+		if (err == -EIO)  {
+			printk(DRV_NAME ": NatFeat Ethernet not found. Module not loaded.\n");
+		}
+		return err;
+	}
+#endif
+
+        return 0;
+}
+
+void atari_nfeth_cleanup(void)
+{
+        unregister_netdev(&atari_nfeth_dev);
+        free_netdev(atari_nfeth_dev); // ?
+}
+
+module_init(atari_nfeth_init);
+module_exit(atari_nfeth_cleanup);
+
+#endif /* MODULE */
+
+/*
+vim:ts=4:sw=4:
+*/
diff -urN linux-m68k/include/asm-m68k/raw_io.h linux-schmitz/include/asm-m68k/raw_io.h
--- linux-m68k/include/asm-m68k/raw_io.h	2006-09-20 05:42:06.000000000 +0200
+++ linux-schmitz/include/asm-m68k/raw_io.h	2006-11-19 21:37:27.000000000 +0100
@@ -54,6 +54,46 @@
 #define raw_outw(val,port) out_be16((port),(val))
 #define raw_outl(val,port) out_be32((port),(val))
 
+/* 
+ * Atari ROM port (cartridge port) ISA adapter, used for the EtherNEC NE2000
+ * network card driver.
+ * The ISA adapter connects address lines A9-A13 to ISA address lines A0-A4, 
+ * and hardwires the rest of the ISA addresses for a base address of 0x300. 
+ *
+ * Data lines D8-D15 are connected to ISA data lines D0-D7 for reading. 
+ * For writes, address lines A1-A8 are latched to ISA data lines D0-D7 
+ * (meaning the bit pattern on A1-A8 can be read back as byte).
+ * 
+ * Reads and writes are byte only. 
+ */
+
+#if defined(CONFIG_ATARI_ROM_ISA)
+#define rom_in_8(addr) \
+    ({ u16 __v = (*(__force volatile u16 *) (addr)); __v >>= 8; __v; })
+#define rom_in_be16(addr) \
+    ({ u16 __v = (*(__force volatile u16 *) (addr)); __v >>= 8; __v; })
+#define rom_in_be32(addr) \
+    ({ u32 __v = (*(__force volatile u32 *) (addr)); __v >>= 8; __v; })
+#define rom_in_le16(addr) \
+    ({ u16 __v = le16_to_cpu(*(__force volatile u16 *) (addr)); __v >>= 8; __v; })
+#define rom_in_le32(addr) \
+    ({ u32 __v = le32_to_cpu(*(__force volatile u32 *) (addr)); __v >>= 8; __v; })
+
+#define rom_out_8(addr,b)     ({u8 __w, __v = (b);            __w = ((*(__force volatile u8 *)  ((addr) + 0x10000 + (__v<<1)))); })
+#define rom_out_be16(addr,w) ({u16 __w, __v = (w);            __w = ((*(__force volatile u16 *) ((addr) + 0x10000 + (__v<<1)))); })
+#define rom_out_be32(addr,l) ({u32 __w, __v = (l);            __w = ((*(__force volatile u32 *) ((addr) + 0x10000 + (__v<<1)))); })
+#define rom_out_le16(addr,w) ({u16 __w, __v = cpu_to_le16(w); __w = ((*(__force volatile u16 *) ((addr) + 0x10000 + (__v<<1)))); })
+#define rom_out_le32(addr,l) ({u32 __w, __v = cpu_to_le32(l); __w = ((*(__force volatile u32 *) ((addr) + 0x10000 + (__v<<1)))); })
+
+#define raw_rom_inb rom_in_8
+#define raw_rom_inw rom_in_be16
+#define raw_rom_inl rom_in_be32
+
+#define raw_rom_outb(val,port) rom_out_8((port),(val))
+#define raw_rom_outw(val,port) rom_out_be16((port),(val))
+#define raw_rom_outl(val,port) rom_out_be32((port),(val))
+#endif /* CONFIG_ATARI_ROM_ISA */
+
 static inline void raw_insb(volatile u8 __iomem *port, u8 *buf, unsigned int len)
 {
 	unsigned int i;
@@ -336,6 +376,62 @@
 		: "d0", "a0", "a1", "d6");
 }
 
+
+#if defined(CONFIG_ATARI_ROM_ISA)
+static inline void raw_rom_insb(volatile u8 __iomem *port, u8 *buf, unsigned int len)
+{
+	unsigned int i;
+
+        for (i = 0; i < len; i++)
+		*buf++ = rom_in_8(port);
+}
+
+static inline void raw_rom_outsb(volatile u8 __iomem *port, const u8 *buf,
+			     unsigned int len)
+{
+	unsigned int i;
+
+        for (i = 0; i < len; i++)
+		rom_out_8(port, *buf++);
+}
+
+static inline void raw_rom_insw(volatile u16 __iomem *port, u16 *buf,
+				   unsigned int nr)
+{
+    unsigned int i;
+
+    for (i = 0; i < nr; i++)
+	*buf++ = rom_in_be16(port);
+}
+
+static inline void raw_rom_outsw(volatile u16 __iomem *port, const u16 *buf,
+				   unsigned int nr)
+{
+    unsigned int i;
+
+    for (i = 0; i < nr; i++)
+	rom_out_be16(port, *buf++);
+}
+
+static inline void raw_rom_insw_swapw(volatile u16 __iomem *port, u16 *buf,
+				   unsigned int nr)
+{
+    unsigned int i;
+
+    for (i = 0; i < nr; i++)
+	*buf++ = rom_in_le16(port);
+}
+
+static inline void raw_rom_outsw_swapw(volatile u16 __iomem *port, const u16 *buf,
+				   unsigned int nr)
+{
+    unsigned int i;
+
+    for (i = 0; i < nr; i++)
+	rom_out_le16(port, *buf++);
+}
+#endif /* CONFIG_ATARI_ROM_ISA */
+
 #define __raw_writel raw_outl
 
 #endif /* __KERNEL__ */
