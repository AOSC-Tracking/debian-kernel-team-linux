From 2c1b2f728e1ae136ec1713bfec9892cf7cd656b6 Mon Sep 17 00:00:00 2001
From: Vitaliy Gusev <vgusev@openvz.org>
Date: Wed, 24 Sep 2008 14:51:32 +0400
Subject: [PATCH] conntrack: Allocate/free ve_nf_conntrack_l3proto_ipv6

Virtualize nf_ct_ipv6_sysctl_table and allocate/free ve_nf_conntrack_l3proto_ipv6.

Per VE nf_ct_ipv6_sysctl_table sysctl registration looks like:

	nf_conntrack_l3proto_register(struct nf_conntrack_l3proto *proto)
		nf_ct_l3proto_register_sysctl(proto);
			nf_ct_register_sysctl(&l3proto->ctl_table_header,
						l3proto->ctl_table_path,
						l3proto->ctl_table, NULL);

So ve_nf_conntrack_l3proto_ipv6 is allocated per VE as l3proto sysctl
registration changes l3proto->ctl_table_header.

Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
---
 net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c |   34 +++++++++++++++++++++++-
 net/ipv6/netfilter/nf_conntrack_reasm.c        |   25 +++++++++++++++++-
 2 files changed, 57 insertions(+), 2 deletions(-)

diff --git a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index 71b15ab..8623b7c 100644
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@ -360,6 +360,33 @@ MODULE_ALIAS("nf_conntrack-" __stringify(AF_INET6));
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Yasuyuki KOZAKAI @USAGI <yasuyuki.kozakai@toshiba.co.jp>");
 
+static int nf_ct_proto_ipv6_init_net(struct net *net)
+{
+	struct nf_conntrack_l3proto *ipv6;
+
+	ipv6 = &nf_conntrack_l3proto_ipv6;
+	if (net != &init_net) {
+		ipv6 = kmemdup(ipv6,
+			       sizeof(struct nf_conntrack_l3proto), GFP_KERNEL);
+		if (!ipv6)
+			return -ENOMEM;
+	}
+
+	ve_nf_conntrack_l3proto_ipv6 = ipv6;
+	return 0;
+}
+
+static void nf_ct_proto_ipv6_exit_net(struct net *net)
+{
+	if (net != &init_net)
+		kfree(ve_nf_conntrack_l3proto_ipv6);
+}
+
+static struct pernet_operations nf_ct_ipv6_ops = {
+	.init = nf_ct_proto_ipv6_init_net,
+	.exit = nf_ct_proto_ipv6_exit_net,
+};
+
 int init_nf_ct_l3proto_ipv6(void)
 {
 	int ret = -ENOMEM;
@@ -435,10 +462,12 @@ static int __init nf_conntrack_l3proto_ipv6_init(void)
 
 	need_conntrack();
 
+	register_pernet_subsys(&nf_ct_ipv6_ops);
+
 	ret = nf_ct_frag6_init();
 	if (ret < 0) {
 		printk("nf_conntrack_ipv6: can't initialize frag6.\n");
-		return ret;
+		goto unreg_subsys;
 	}
 
 	ret = init_nf_ct_l3proto_ipv6();
@@ -461,6 +490,8 @@ static int __init nf_conntrack_l3proto_ipv6_init(void)
 
 cleanup_frag6:
 	nf_ct_frag6_cleanup();
+unreg_subsys:
+	unregister_pernet_subsys(&nf_ct_ipv6_ops);
 	return ret;
 }
 
@@ -473,6 +504,7 @@ static void __exit nf_conntrack_l3proto_ipv6_fini(void)
 	nf_unregister_hooks(ipv6_conntrack_ops, ARRAY_SIZE(ipv6_conntrack_ops));
 	fini_nf_ct_l3proto_ipv6();
 	nf_ct_frag6_cleanup();
+	unregister_pernet_subsys(&nf_ct_ipv6_ops);
 }
 
 module_init(nf_conntrack_l3proto_ipv6_init);
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 9faaa59..e8e4112 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -40,6 +40,7 @@
 #include <net/ndisc.h>
 #include <net/addrconf.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+#include <net/netfilter/nf_conntrack_l3proto.h>
 #include <linux/sysctl.h>
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
@@ -696,17 +697,39 @@ static int nf_ct_frag6_init_net(struct net *net)
 {
 	struct netns_frags *frags = &net->ipv6.ct_frags;
 
+#ifdef CONFIG_SYSCTL
+	if (net != &init_net) {
+		struct nf_conntrack_l3proto *ipv6 =
+			ve_nf_conntrack_l3proto_ipv6;
+
+		ipv6->ctl_table = kmemdup(nf_ct_ipv6_sysctl_table,
+					  sizeof(nf_ct_ipv6_sysctl_table),
+					  GFP_KERNEL);
+		if (!ipv6->ctl_table)
+			return -ENOMEM;
+
+		ipv6->ctl_table_header = NULL;
+		ipv6->ctl_table_path = nf_net_netfilter_sysctl_path;
+
+		ipv6->ctl_table[0].data = &frags->timeout;
+		ipv6->ctl_table[1].data = &frags->low_thresh;
+		ipv6->ctl_table[2].data = &frags->high_thresh;
+	}
+#endif
 	frags->timeout = IPV6_FRAG_TIMEOUT;
 	frags->high_thresh = 256 * 1024;
 	frags->low_thresh = 192 * 1024;
 	inet_frags_init_net(frags);
 
-	return 0; /* FIXME : sysctls */
+	return 0;
 }
 
 static void nf_ct_frag6_exit_net(struct net *net)
 {
 	inet_frags_exit_net(&net->ipv6.ct_frags, &nf_frags);
+	if (net != &init_net)
+		kfree(ve_nf_conntrack_l3proto_ipv6->ctl_table);
+
 }
 
 static struct pernet_operations nf_ct_frag6_ops = {
-- 
1.6.0.6

