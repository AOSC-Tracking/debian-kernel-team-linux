From a5aec9d8e0e2c317cbd2474880a420867ad58eb0 Mon Sep 17 00:00:00 2001
From: Sylvain Munaut <tnt@246tNt.com>
Date: Sun, 13 May 2007 14:26:36 +0200
Subject: [PATCH 15/21] powerpc: BestComm, Replace global variable bcom by bcom_eng

Since this is global and exported, this name is less likely
to have collision problems.

Signed-off-by: Sylvain Munaut <tnt@246tNt.com>
---
 arch/powerpc/sysdev/bestcomm/ata.c           |    8 +-
 arch/powerpc/sysdev/bestcomm/bestcomm.c      |  110 +++++++++++++-------------
 arch/powerpc/sysdev/bestcomm/bestcomm_priv.h |   22 +++---
 arch/powerpc/sysdev/bestcomm/fec.c           |   12 ++--
 arch/powerpc/sysdev/bestcomm/gen_bd.c        |   12 ++--
 5 files changed, 82 insertions(+), 82 deletions(-)

diff --git a/arch/powerpc/sysdev/bestcomm/ata.c b/arch/powerpc/sysdev/bestcomm/ata.c
index edc2049..39efb9b 100644
--- a/arch/powerpc/sysdev/bestcomm/ata.c
+++ b/arch/powerpc/sysdev/bestcomm/ata.c
@@ -77,7 +77,7 @@ bcom_ata_init(int queue_len, int maxbufsize)
 		return NULL;
 	}
 
-	var->enable	= bcom->regs_base +
+	var->enable	= bcom_eng->regs_base +
 				offsetof(struct mpc52xx_sdma, tcr[tsk->tasknum]);
 	var->bd_base	= tsk->bd_pa;
 	var->bd_last	= tsk->bd_pa + ((tsk->num_bd-1) * tsk->bd_size);
@@ -88,10 +88,10 @@ bcom_ata_init(int queue_len, int maxbufsize)
 	bcom_set_task_pragma(tsk->tasknum, BCOM_ATA_PRAGMA);
 	bcom_set_task_auto_start(tsk->tasknum, tsk->tasknum);
 
-	out_8(&bcom->regs->ipr[BCOM_INITIATOR_ATA_RX], BCOM_IPR_ATA_RX);
-	out_8(&bcom->regs->ipr[BCOM_INITIATOR_ATA_TX], BCOM_IPR_ATA_TX);
+	out_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_ATA_RX], BCOM_IPR_ATA_RX);
+	out_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_ATA_TX], BCOM_IPR_ATA_TX);
 
-	out_be32(&bcom->regs->IntPend, 1<<tsk->tasknum); /* Clear ints */
+	out_be32(&bcom_eng->regs->IntPend, 1<<tsk->tasknum); /* Clear ints */
 
 	return tsk;
 }
diff --git a/arch/powerpc/sysdev/bestcomm/bestcomm.c b/arch/powerpc/sysdev/bestcomm/bestcomm.c
index 589e37d..22684e7 100644
--- a/arch/powerpc/sysdev/bestcomm/bestcomm.c
+++ b/arch/powerpc/sysdev/bestcomm/bestcomm.c
@@ -29,8 +29,8 @@
 #define DRIVER_NAME "bestcomm-core"
 
 
-struct bcom_engine *bcom = NULL;
-EXPORT_SYMBOL_GPL(bcom);	/* needed for inline functions */
+struct bcom_engine *bcom_eng = NULL;
+EXPORT_SYMBOL_GPL(bcom_eng);	/* needed for inline functions */
 
 
 /* ======================================================================== */
@@ -151,16 +151,16 @@ bcom_task_alloc(int bd_count, int bd_size, int priv_size)
 	struct bcom_task *tsk;
 
 	/* Get and reserve a task num */
-	spin_lock(&bcom->lock);
+	spin_lock(&bcom_eng->lock);
 
 	for (i=0; i<BCOM_MAX_TASKS; i++)
-		if (!bcom->tdt[i].stop) {	/* we use stop as a marker */
-			bcom->tdt[i].stop = 0xfffffffful; /* dummy addr */
+		if (!bcom_eng->tdt[i].stop) {	/* we use stop as a marker */
+			bcom_eng->tdt[i].stop = 0xfffffffful; /* dummy addr */
 			tasknum = i;
 			break;
 		}
 
-	spin_unlock(&bcom->lock);
+	spin_unlock(&bcom_eng->lock);
 
 	if (tasknum < 0)
 		return NULL;
@@ -175,7 +175,7 @@ bcom_task_alloc(int bd_count, int bd_size, int priv_size)
 		tsk->priv = (void*)tsk + sizeof(struct bcom_task);
 
 	/* Get IRQ of that task */
-	tsk->irq = irq_of_parse_and_map(bcom->ofnode, tsk->tasknum);
+	tsk->irq = irq_of_parse_and_map(bcom_eng->ofnode, tsk->tasknum);
 	if (tsk->irq == NO_IRQ)
 		goto error;
 
@@ -205,7 +205,7 @@ error:
 		kfree(tsk);
 	}
 
-	bcom->tdt[tasknum].stop = 0;
+	bcom_eng->tdt[tasknum].stop = 0;
 
 	return NULL;
 }
@@ -218,8 +218,8 @@ bcom_task_release(struct bcom_task *tsk)
 	bcom_disable_task(tsk->tasknum);
 
 	/* Clear TDT */
-	bcom->tdt[tsk->tasknum].start = 0;
-	bcom->tdt[tsk->tasknum].stop  = 0;
+	bcom_eng->tdt[tsk->tasknum].start = 0;
+	bcom_eng->tdt[tsk->tasknum].stop  = 0;
 
 	/* Free everything */
 	irq_dispose_mapping(tsk->irq);
@@ -251,7 +251,7 @@ bcom_load_image(int task, u32 *task_image)
 	}
 
 	/* Initial load or reload */
-	tdt = &bcom->tdt[task];
+	tdt = &bcom_eng->tdt[task];
 
 	if (tdt->start) {
 		desc = bcom_task_desc(task);
@@ -380,55 +380,55 @@ bcom_engine_init(void)
 	var_size = BCOM_MAX_TASKS * (BCOM_VAR_SIZE + BCOM_INC_SIZE);
 	fdt_size = BCOM_FDT_SIZE;
 
-	bcom->tdt = bcom_sram_alloc(tdt_size, sizeof(u32), &tdt_pa);
-	bcom->ctx = bcom_sram_alloc(ctx_size, BCOM_CTX_ALIGN, &ctx_pa);
-	bcom->var = bcom_sram_alloc(var_size, BCOM_VAR_ALIGN, &var_pa);
-	bcom->fdt = bcom_sram_alloc(fdt_size, BCOM_FDT_ALIGN, &fdt_pa);
+	bcom_eng->tdt = bcom_sram_alloc(tdt_size, sizeof(u32), &tdt_pa);
+	bcom_eng->ctx = bcom_sram_alloc(ctx_size, BCOM_CTX_ALIGN, &ctx_pa);
+	bcom_eng->var = bcom_sram_alloc(var_size, BCOM_VAR_ALIGN, &var_pa);
+	bcom_eng->fdt = bcom_sram_alloc(fdt_size, BCOM_FDT_ALIGN, &fdt_pa);
 
-	if (!bcom->tdt || !bcom->ctx || !bcom->var || !bcom->fdt) {
+	if (!bcom_eng->tdt || !bcom_eng->ctx || !bcom_eng->var || !bcom_eng->fdt) {
 		printk(KERN_ERR "DMA: SRAM alloc failed in engine init !\n");
 
-		bcom_sram_free(bcom->tdt);
-		bcom_sram_free(bcom->ctx);
-		bcom_sram_free(bcom->var);
-		bcom_sram_free(bcom->fdt);
+		bcom_sram_free(bcom_eng->tdt);
+		bcom_sram_free(bcom_eng->ctx);
+		bcom_sram_free(bcom_eng->var);
+		bcom_sram_free(bcom_eng->fdt);
 
 		return -ENOMEM;
 	}
 
-	memset(bcom->tdt, 0x00, tdt_size);
-	memset(bcom->ctx, 0x00, ctx_size);
-	memset(bcom->var, 0x00, var_size);
-	memset(bcom->fdt, 0x00, fdt_size);
+	memset(bcom_eng->tdt, 0x00, tdt_size);
+	memset(bcom_eng->ctx, 0x00, ctx_size);
+	memset(bcom_eng->var, 0x00, var_size);
+	memset(bcom_eng->fdt, 0x00, fdt_size);
 
 	/* Copy the FDT for the EU#3 */
-	memcpy(&bcom->fdt[48], fdt_ops, sizeof(fdt_ops));
+	memcpy(&bcom_eng->fdt[48], fdt_ops, sizeof(fdt_ops));
 
 	/* Initialize Task base structure */
 	for (task=0; task<BCOM_MAX_TASKS; task++)
 	{
-		out_be16(&bcom->regs->tcr[task], 0);
-		out_8(&bcom->regs->ipr[task], 0);
+		out_be16(&bcom_eng->regs->tcr[task], 0);
+		out_8(&bcom_eng->regs->ipr[task], 0);
 
-		bcom->tdt[task].context	= ctx_pa;
-		bcom->tdt[task].var	= var_pa;
-		bcom->tdt[task].fdt	= fdt_pa;
+		bcom_eng->tdt[task].context	= ctx_pa;
+		bcom_eng->tdt[task].var	= var_pa;
+		bcom_eng->tdt[task].fdt	= fdt_pa;
 
 		var_pa += BCOM_VAR_SIZE + BCOM_INC_SIZE;
 		ctx_pa += BCOM_CTX_SIZE;
 	}
 
-	out_be32(&bcom->regs->taskBar, tdt_pa);
+	out_be32(&bcom_eng->regs->taskBar, tdt_pa);
 
 	/* Init 'always' initiator */
-	out_8(&bcom->regs->ipr[BCOM_INITIATOR_ALWAYS], BCOM_IPR_ALWAYS);
+	out_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_ALWAYS], BCOM_IPR_ALWAYS);
 
 	/* Disable COMM Bus Prefetch, apparently it's not reliable yet */
 	/* FIXME: This should be done on 5200 and not 5200B ... */
-	out_be16(&bcom->regs->PtdCntrl, in_be16(&bcom->regs->PtdCntrl) | 1);
+	out_be16(&bcom_eng->regs->PtdCntrl, in_be16(&bcom_eng->regs->PtdCntrl) | 1);
 
 	/* Init lock */
-	spin_lock_init(&bcom->lock);
+	spin_lock_init(&bcom_eng->lock);
 
 	return 0;
 }
@@ -441,17 +441,17 @@ bcom_engine_cleanup(void)
 	/* Stop all tasks */
 	for (task=0; task<BCOM_MAX_TASKS; task++)
 	{
-		out_be16(&bcom->regs->tcr[task], 0);
-		out_8(&bcom->regs->ipr[task], 0);
+		out_be16(&bcom_eng->regs->tcr[task], 0);
+		out_8(&bcom_eng->regs->ipr[task], 0);
 	}
 
-	out_be32(&bcom->regs->taskBar, 0ul);
+	out_be32(&bcom_eng->regs->taskBar, 0ul);
 
 	/* Release the SRAM zones */
-	bcom_sram_free(bcom->tdt);
-	bcom_sram_free(bcom->ctx);
-	bcom_sram_free(bcom->var);
-	bcom_sram_free(bcom->fdt);
+	bcom_sram_free(bcom_eng->tdt);
+	bcom_sram_free(bcom_eng->ctx);
+	bcom_sram_free(bcom_eng->var);
+	bcom_sram_free(bcom_eng->fdt);
 }
 
 
@@ -497,8 +497,8 @@ mpc52xx_bcom_init(void)
 	}
 
 	/* Get a clean struct */
-	bcom = kzalloc(sizeof(struct bcom_engine), GFP_KERNEL);
-	if (!bcom) {
+	bcom_eng = kzalloc(sizeof(struct bcom_engine), GFP_KERNEL);
+	if (!bcom_eng) {
 		printk(KERN_ERR DRIVER_NAME ": "
 			"Can't allocate state structure\n");
 		rv = -ENOMEM;
@@ -506,10 +506,10 @@ mpc52xx_bcom_init(void)
 	}
 
 	/* Save the node */
-	bcom->ofnode = ofn_bcom;
+	bcom_eng->ofnode = ofn_bcom;
 
 	/* Get, reserve & map io */
-	if (of_address_to_resource(bcom->ofnode, 0, &res_bcom)) {
+	if (of_address_to_resource(bcom_eng->ofnode, 0, &res_bcom)) {
 		printk(KERN_ERR DRIVER_NAME ": "
 			"Can't get resource\n");
 		rv = -EINVAL;
@@ -524,9 +524,9 @@ mpc52xx_bcom_init(void)
 		goto error_sramclean;
 	}
 
-	bcom->regs_base = res_bcom.start;
-	bcom->regs = ioremap(res_bcom.start, sizeof(struct mpc52xx_sdma));
-	if (!bcom->regs) {
+	bcom_eng->regs_base = res_bcom.start;
+	bcom_eng->regs = ioremap(res_bcom.start, sizeof(struct mpc52xx_sdma));
+	if (!bcom_eng->regs) {
 		printk(KERN_ERR DRIVER_NAME ": "
 			"Can't map registers\n");
 		rv = -ENOMEM;
@@ -540,19 +540,19 @@ mpc52xx_bcom_init(void)
 
 	/* Done ! */
 	printk(KERN_INFO "DMA: MPC52xx BestComm engine @%08lx ok !\n",
-		bcom->regs_base);
+		bcom_eng->regs_base);
 
 	return 0;
 
 	/* Error path */
 error_unmap:
-	iounmap(bcom->regs);
+	iounmap(bcom_eng->regs);
 error_release:
 	release_mem_region(res_bcom.start, sizeof(struct mpc52xx_sdma));
 error_sramclean:
 	bcom_sram_cleanup();
 error_ofput:
-	of_node_put(bcom->ofnode);
+	of_node_put(bcom_eng->ofnode);
 
 	printk(KERN_ERR "DMA: MPC52xx BestComm init failed !\n");
 
@@ -569,14 +569,14 @@ mpc52xx_bcom_exit(void)
 	bcom_sram_cleanup();
 
 	/* Release regs */
-	iounmap(bcom->regs);
-	release_mem_region(bcom->regs_base, sizeof(struct mpc52xx_sdma));
+	iounmap(bcom_eng->regs);
+	release_mem_region(bcom_eng->regs_base, sizeof(struct mpc52xx_sdma));
 
 	/* Release the node */
-	of_node_put(bcom->ofnode);
+	of_node_put(bcom_eng->ofnode);
 
 	/* Release memory */
-	kfree(bcom);
+	kfree(bcom_eng);
 }
 
 #ifdef MODULE
diff --git a/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h b/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
index d43b00a..6f33f0c 100644
--- a/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
+++ b/arch/powerpc/sysdev/bestcomm/bestcomm_priv.h
@@ -68,7 +68,7 @@ struct bcom_engine {
 	spinlock_t			lock;
 };
 
-extern struct bcom_engine *bcom;
+extern struct bcom_engine *bcom_eng;
 
 
 /* ======================================================================== */
@@ -236,34 +236,34 @@ static inline void
 bcom_enable_task(int task)
 {
         u16 reg;
-        reg = in_be16(&bcom->regs->tcr[task]);
-        out_be16(&bcom->regs->tcr[task],  reg | TASK_ENABLE);
+        reg = in_be16(&bcom_eng->regs->tcr[task]);
+        out_be16(&bcom_eng->regs->tcr[task],  reg | TASK_ENABLE);
 }
 
 static inline void
 bcom_disable_task(int task)
 {
-        u16 reg = in_be16(&bcom->regs->tcr[task]);
-        out_be16(&bcom->regs->tcr[task], reg & ~TASK_ENABLE);
+        u16 reg = in_be16(&bcom_eng->regs->tcr[task]);
+        out_be16(&bcom_eng->regs->tcr[task], reg & ~TASK_ENABLE);
 }
 
 
 static inline u32 *
 bcom_task_desc(int task)
 {
-	return bcom_sram_pa2va(bcom->tdt[task].start);
+	return bcom_sram_pa2va(bcom_eng->tdt[task].start);
 }
 
 static inline int
 bcom_task_num_descs(int task)
 {
-	return (bcom->tdt[task].stop - bcom->tdt[task].start)/sizeof(u32) + 1;
+	return (bcom_eng->tdt[task].stop - bcom_eng->tdt[task].start)/sizeof(u32) + 1;
 }
 
 static inline u32 *
 bcom_task_var(int task)
 {
-	return bcom_sram_pa2va(bcom->tdt[task].var);
+	return bcom_sram_pa2va(bcom_eng->tdt[task].var);
 }
 
 static inline u32 *
@@ -302,21 +302,21 @@ bcom_set_desc_initiator(u32 *desc, int initiator)
 static inline void
 bcom_set_task_pragma(int task, int pragma)
 {
-	u32 *fdt = &bcom->tdt[task].fdt;
+	u32 *fdt = &bcom_eng->tdt[task].fdt;
 	*fdt = (*fdt & ~0xff) | pragma;
 }
 
 static inline void
 bcom_set_task_auto_start(int task, int next_task)
 {
-	u16 __iomem *tcr = &bcom->regs->tcr[task];
+	u16 __iomem *tcr = &bcom_eng->regs->tcr[task];
 	out_be16(tcr, (in_be16(tcr) & ~0xff) | 0x00c0 | next_task);
 }
 
 static inline void
 bcom_set_tcr_initiator(int task, int initiator)
 {
-	u16 __iomem *tcr = &bcom->regs->tcr[task];
+	u16 __iomem *tcr = &bcom_eng->regs->tcr[task];
 	out_be16(tcr, (in_be16(tcr) & ~0x1f00) | ((initiator & 0x1f) << 8));
 }
 
diff --git a/arch/powerpc/sysdev/bestcomm/fec.c b/arch/powerpc/sysdev/bestcomm/fec.c
index 43f9551..1d7bf40 100644
--- a/arch/powerpc/sysdev/bestcomm/fec.c
+++ b/arch/powerpc/sysdev/bestcomm/fec.c
@@ -124,7 +124,7 @@ bcom_fec_rx_reset(struct bcom_task *tsk)
 	if (bcom_load_image(tsk->tasknum, bcom_fec_rx_task))
 		return -1;
 
-	var->enable	= bcom->regs_base +
+	var->enable	= bcom_eng->regs_base +
 				offsetof(struct mpc52xx_sdma, tcr[tsk->tasknum]);
 	var->fifo	= (u32) priv->fifo;
 	var->bd_base	= tsk->bd_pa;
@@ -146,9 +146,9 @@ bcom_fec_rx_reset(struct bcom_task *tsk)
 	bcom_set_task_pragma(tsk->tasknum, BCOM_FEC_RX_BD_PRAGMA);
 	bcom_set_task_auto_start(tsk->tasknum, tsk->tasknum);
 
-	out_8(&bcom->regs->ipr[BCOM_INITIATOR_FEC_RX], BCOM_IPR_FEC_RX);
+	out_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_FEC_RX], BCOM_IPR_FEC_RX);
 
-	out_be32(&bcom->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
+	out_be32(&bcom_eng->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
 
 	return 0;
 }
@@ -225,7 +225,7 @@ bcom_fec_tx_reset(struct bcom_task *tsk)
 	if (bcom_load_image(tsk->tasknum, bcom_fec_tx_task))
 		return -1;
 
-	var->enable	= bcom->regs_base +
+	var->enable	= bcom_eng->regs_base +
 				offsetof(struct mpc52xx_sdma, tcr[tsk->tasknum]);
 	var->fifo	= (u32) priv->fifo;
 	var->DRD	= bcom_sram_va2pa(self_modified_drd(tsk->tasknum));
@@ -247,9 +247,9 @@ bcom_fec_tx_reset(struct bcom_task *tsk)
 	bcom_set_task_pragma(tsk->tasknum, BCOM_FEC_TX_BD_PRAGMA);
 	bcom_set_task_auto_start(tsk->tasknum, tsk->tasknum);
 
-	out_8(&bcom->regs->ipr[BCOM_INITIATOR_FEC_TX], BCOM_IPR_FEC_TX);
+	out_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_FEC_TX], BCOM_IPR_FEC_TX);
 
-	out_be32(&bcom->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
+	out_be32(&bcom_eng->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
 
 	return 0;
 }
diff --git a/arch/powerpc/sysdev/bestcomm/gen_bd.c b/arch/powerpc/sysdev/bestcomm/gen_bd.c
index 7e88681..4470482 100644
--- a/arch/powerpc/sysdev/bestcomm/gen_bd.c
+++ b/arch/powerpc/sysdev/bestcomm/gen_bd.c
@@ -131,7 +131,7 @@ bcom_gen_bd_rx_reset(struct bcom_task *tsk)
 	if (bcom_load_image(tsk->tasknum, bcom_gen_bd_rx_task))
 		return -1;
 
-	var->enable	= bcom->regs_base +
+	var->enable	= bcom_eng->regs_base +
 				offsetof(struct mpc52xx_sdma, tcr[tsk->tasknum]);
 	var->fifo	= (u32) priv->fifo;
 	var->bd_base	= tsk->bd_pa;
@@ -152,10 +152,10 @@ bcom_gen_bd_rx_reset(struct bcom_task *tsk)
 	bcom_set_task_pragma(tsk->tasknum, BCOM_GEN_RX_BD_PRAGMA);
 	bcom_set_task_auto_start(tsk->tasknum, tsk->tasknum);
 
-	out_8(&bcom->regs->ipr[priv->initiator], priv->ipr);
+	out_8(&bcom_eng->regs->ipr[priv->initiator], priv->ipr);
 	bcom_set_initiator(tsk->tasknum, priv->initiator);
 
-	out_be32(&bcom->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
+	out_be32(&bcom_eng->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
 
 	return 0;
 }
@@ -215,7 +215,7 @@ bcom_gen_bd_tx_reset(struct bcom_task *tsk)
 	if (bcom_load_image(tsk->tasknum, bcom_gen_bd_tx_task))
 		return -1;
 
-	var->enable	= bcom->regs_base +
+	var->enable	= bcom_eng->regs_base +
 				offsetof(struct mpc52xx_sdma, tcr[tsk->tasknum]);
 	var->fifo	= (u32) priv->fifo;
 	var->bd_base	= tsk->bd_pa;
@@ -236,10 +236,10 @@ bcom_gen_bd_tx_reset(struct bcom_task *tsk)
 	bcom_set_task_pragma(tsk->tasknum, BCOM_GEN_TX_BD_PRAGMA);
 	bcom_set_task_auto_start(tsk->tasknum, tsk->tasknum);
 
-	out_8(&bcom->regs->ipr[priv->initiator], priv->ipr);
+	out_8(&bcom_eng->regs->ipr[priv->initiator], priv->ipr);
 	bcom_set_initiator(tsk->tasknum, priv->initiator);
 
-	out_be32(&bcom->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
+	out_be32(&bcom_eng->regs->IntPend, 1<<tsk->tasknum);	/* Clear ints */
 
 	return 0;
 }
-- 
1.5.1.2

